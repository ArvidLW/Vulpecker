diff --git a/content/media/nsBuiltinDecoderReader.cpp b/content/media/nsBuiltinDecoderReader.cpp
--- a/content/media/nsBuiltinDecoderReader.cpp
+++ b/content/media/nsBuiltinDecoderReader.cpp
@@ -40,16 +40,17 @@
 #include "nsISeekableStream.h"
 #include "nsClassHashtable.h"
 #include "nsTArray.h"
 #include "nsBuiltinDecoder.h"
 #include "nsBuiltinDecoderReader.h"
 #include "nsBuiltinDecoderStateMachine.h"
 #include "mozilla/mozalloc.h"
 #include "VideoUtils.h"
+#include "nsTimeRanges.h"
 
 using namespace mozilla;
 using mozilla::layers::ImageContainer;
 using mozilla::layers::PlanarYCbCrImage;
 
 using mozilla::layers::PlanarYCbCrImage;
 
 // Verify these values are sane. Once we've checked the frame sizes, we then
@@ -369,10 +370,8 @@ nsresult nsBuiltinDecoderReader::DecodeT
                                               channels));
       delete mAudioQueue.PopFront();
       mAudioQueue.PushFront(data.forget());
       break;
     }
   }
   return NS_OK;
 }
-
-
diff --git a/content/media/nsBuiltinDecoderStateMachine.cpp b/content/media/nsBuiltinDecoderStateMachine.cpp
--- a/content/media/nsBuiltinDecoderStateMachine.cpp
+++ b/content/media/nsBuiltinDecoderStateMachine.cpp
@@ -1236,23 +1236,66 @@ nsresult nsBuiltinDecoderStateMachine::D
       !IsPlaying())
   {
     StartPlayback();
   }
 
   return NS_OK;
 }
 
+PRBool nsBuiltinDecoderStateMachine::IsSeekTargetUnreachable()
+{
+  if (GetSeekable()) {
+    return PR_FALSE;
+  }
+  nsTimeRanges buffered;
+  nsresult res = mDecoder->GetBuffered(&buffered);
+  NS_ENSURE_SUCCESS(res, PR_TRUE);
+  double target = static_cast<double>(mSeekTime) / USECS_PER_S;
+  nsIDOMTimeRanges* r = static_cast<nsIDOMTimeRanges*>(&buffered);
+  PRUint32 length = 0;
+  r->GetLength(&length);
+  for (PRUint32 index = 0; index < length; ++index) {
+    double start, end;
+    r->Start(index, &start);
+    r->End(index, &end);
+    if (start <= target && target <= end) {
+      return PR_FALSE;
+    }
+  }
+  return PR_TRUE;
+}
+
 void nsBuiltinDecoderStateMachine::DecodeSeek()
 {
   NS_ASSERTION(OnDecodeThread(), "Should be on decode thread.");
   mDecoder->GetReentrantMonitor().AssertCurrentThreadIn();
   NS_ASSERTION(mState == DECODER_STATE_SEEKING,
                "Only call when in seeking state");
 
+  if (IsSeekTargetUnreachable()) {
+    nsCOMPtr<nsIRunnable> event;
+    // The server doesn't support HTTP byte range requests, and the seek
+    // target doesn't lie in a buffered range. We cannot seek there, so
+    // just abort the seek without doing anything. We'll resume playback
+    // where we were before the seek.
+    {
+      ReentrantMonitorAutoExit exitMon(mDecoder->GetReentrantMonitor());
+      event = NS_NewRunnableMethod(mDecoder, &nsBuiltinDecoder::SeekingStarted);
+      NS_DispatchToMainThread(event, NS_DISPATCH_SYNC);
+    }
+    StartDecoding();
+    {
+      ReentrantMonitorAutoExit exitMon(mDecoder->GetReentrantMonitor());
+      event = NS_NewRunnableMethod(mDecoder, &nsBuiltinDecoder::SeekingStopped);
+      NS_DispatchToMainThread(event, NS_DISPATCH_SYNC);
+    }
+    return;
+  }
+
   // During the seek, don't have a lock on the decoder state,
   // otherwise long seek operations can block the main thread.
   // The events dispatched to the main thread are SYNC calls.
   // These calls are made outside of the decode monitor lock so
   // it is safe for the main thread to makes calls that acquire
   // the lock since it won't deadlock. We check the state when
   // acquiring the lock again in case shutdown has occurred
   // during the time when we didn't have the lock.
diff --git a/content/media/nsBuiltinDecoderStateMachine.h b/content/media/nsBuiltinDecoderStateMachine.h
--- a/content/media/nsBuiltinDecoderStateMachine.h
+++ b/content/media/nsBuiltinDecoderStateMachine.h
@@ -411,16 +411,20 @@ protected:
   // Load metadata. Called on the decode thread. The decoder monitor
   // must be held with exactly one lock count.
   nsresult DecodeMetadata();
 
   // Seeks to mSeekTarget. Called on the decode thread. The decoder monitor
   // must be held with exactly one lock count.
   void DecodeSeek();
 
+  // Returns PR_TRUE if mSeekTarget is not in a buffered range and we
+  // cannot seek the media into unbuffered ranges.
+  PRBool IsSeekTargetUnreachable();
+
   // Decode loop, decodes data until EOF or shutdown.
   // Called on the decode thread.
   void DecodeLoop();
 
   // Decode thread run function. Determines which of the Decode*() functions
   // to call.
   void DecodeThreadRun();
 
