diff --git a/content/canvas/src/WebGLContext.h b/content/canvas/src/WebGLContext.h
--- a/content/canvas/src/WebGLContext.h
+++ b/content/canvas/src/WebGLContext.h
@@ -1094,16 +1094,17 @@ protected:
     WebGLContextOptions mOptions;
 
     bool mInvalidated;
     bool mResetLayer;
     bool mOptionsFrozen;
     bool mMinCapability;
     bool mDisableExtensions;
     bool mHasRobustness;
+    bool mIsMesa;
 
     template<typename WebGLObjectType>
     void DeleteWebGLObjectsArray(nsTArray<WebGLObjectType>& array);
 
     WebGLuint mActiveTexture;
     WebGLenum mWebGLError;
 
     // whether shader validation is supported
@@ -2319,16 +2320,34 @@ public:
         for (uint32_t i = 0; i < mAttachedShaders.Length(); ++i) {
             if (mAttachedShaders[i] && !mAttachedShaders[i]->CompileStatus()) {
                 return true;
             }
         }
         return false;
     }
 
+    size_t UpperBoundNumSamplerUniforms() {
+        size_t numSamplerUniforms = 0;
+        for (size_t i = 0; i < mAttachedShaders.Length(); ++i) {
+            const WebGLShader *shader = mAttachedShaders[i];
+            if (!shader)
+                continue;
+            for (size_t j = 0; j < shader->mUniformInfos.Length(); ++j) {
+                WebGLUniformInfo u = shader->mUniformInfos[j];
+                if (u.type == SH_SAMPLER_2D ||
+                    u.type == SH_SAMPLER_CUBE)
+                {
+                    numSamplerUniforms += u.arraySize;
+                }
+            }
+        }
+        return numSamplerUniforms;
+    }
+
     bool NextGeneration()
     {
         if (!(mGeneration + 1).isValid())
             return false; // must exit without changing mGeneration
         ++mGeneration;
         return true;
     }
 
diff --git a/content/canvas/src/WebGLContextGL.cpp b/content/canvas/src/WebGLContextGL.cpp
--- a/content/canvas/src/WebGLContextGL.cpp
+++ b/content/canvas/src/WebGLContextGL.cpp
@@ -3701,16 +3701,27 @@ WebGLContext::LinkProgram(WebGLProgram *
 
     if (!program->HasBothShaderTypesAttached()) {
         GenerateWarning("linkProgram: this program doesn't have both a vertex shader"
                         " and a fragment shader");
         program->SetLinkStatus(false);
         return;
     }
 
+    // bug 777028
+    // Mesa can't handle more than 16 samplers per program, counting each array entry.
+    if (mIsMesa) {
+        if (program->UpperBoundNumSamplerUniforms() > 16) {
+            GenerateWarning("Programs with more than 16 samplers are disallowed on Mesa drivers "
+                            "to avoid a Mesa crasher.");
+            program->SetLinkStatus(false);
+            return;
+        }
+    }
+
     GLint ok;
     if (gl->WorkAroundDriverBugs() &&
         program->HasBadShaderAttached())
     {
         // it's a common driver bug, caught by program-test.html, that linkProgram doesn't
         // correctly preserve the state of an in-use program that has been attached a bad shader
         // see bug 777883
         ok = false;
@@ -5024,17 +5035,16 @@ WebGLContext::CompileShader(WebGLShader 
         shader->mAttributes.Clear();
         shader->mUniforms.Clear();
         shader->mUniformInfos.Clear();
 
         nsAutoArrayPtr<char> attribute_name(new char[attrib_max_length+1]);
         nsAutoArrayPtr<char> uniform_name(new char[uniform_max_length+1]);
         nsAutoArrayPtr<char> mapped_name(new char[mapped_max_length+1]);
 
-
         for (int i = 0; i < num_uniforms; i++) {
             int length, size;
             ShDataType type;
             ShGetActiveUniform(compiler, i,
                                 &length, &size, &type,
                                 uniform_name,
                                 mapped_name);
             if (useShaderSourceTranslation) {
diff --git a/content/canvas/src/WebGLContextValidate.cpp b/content/canvas/src/WebGLContextValidate.cpp
--- a/content/canvas/src/WebGLContextValidate.cpp
+++ b/content/canvas/src/WebGLContextValidate.cpp
@@ -766,16 +766,19 @@ WebGLContext::InitAndValidateGL()
     if (mShaderValidation) {
         if (!ShInitialize()) {
             GenerateWarning("GLSL translator initialization failed!");
             return false;
         }
     }
 #endif
 
+    // Mesa can only be detected with the GL_VERSION string, of the form "2.1 Mesa 7.11.0"
+    mIsMesa = strstr((const char *)(gl->fGetString(LOCAL_GL_VERSION)), "Mesa");
+
     // notice that the point of calling GetAndClearError here is not only to check for error,
     // it is also to reset the error flags so that a subsequent WebGL getError call will give the correct result.
     error = gl->GetAndClearError();
     if (error != LOCAL_GL_NO_ERROR) {
         GenerateWarning("GL error 0x%x occurred during WebGL context initialization!", error);
         return false;
     }
