diff --git a/docshell/base/nsDocShell.cpp b/docshell/base/nsDocShell.cpp
--- a/docshell/base/nsDocShell.cpp
+++ b/docshell/base/nsDocShell.cpp
@@ -7950,16 +7950,41 @@ private:
     nsCOMPtr<nsIInputStream> mPostData;
     nsCOMPtr<nsIInputStream> mHeadersData;
     nsCOMPtr<nsISHEntry> mSHEntry;
     PRUint32 mFlags;
     PRUint32 mLoadType;
     bool mFirstParty;
 };
 
+namespace {
+
+// Simple RAII class to reset aPtr's value back to its original value, when the
+// AutoResetter is destroyed.
+template<typename T>
+class AutoResetter 
+{
+public:
+    AutoResetter(T *aPtr)
+        : mPtr(aPtr)
+        , mOriginalValue(*aPtr)
+    {}
+
+    ~AutoResetter()
+    {
+        *mPtr = mOriginalValue;
+    }
+
+private:
+    T* mPtr;
+    T  mOriginalValue;
+};
+
+} // anonymous namespace
+
 NS_IMETHODIMP
 nsDocShell::InternalLoad(nsIURI * aURI,
                          nsIURI * aReferrer,
                          nsISupports * aOwner,
                          PRUint32 aFlags,
                          const PRUnichar *aWindowTarget,
                          const char* aTypeHint,
                          nsIInputStream * aPostData,
@@ -8359,16 +8384,22 @@ nsDocShell::InternalLoad(nsIURI * aURI,
             // ScrollToAnchor doesn't necessarily cause us to scroll the window;
             // the function decides whether a scroll is appropriate based on the
             // arguments it receives.  But even if we don't end up scrolling,
             // ScrollToAnchor performs other important tasks, such as informing
             // the presShell that we have a new hash.  See bug 680257.
             rv = ScrollToAnchor(curHash, newHash, aLoadType);
             NS_ENSURE_SUCCESS(rv, rv);
 
+            // Reset mLoadType to its original value once we exit this block,
+            // because this short-circuited load might have started after a
+            // normal, network load, and we don't want to clobber its load type.
+            // See bug 737307.
+            AutoResetter<PRUint32> loadTypeResetter(&mLoadType);
+
             mLoadType = aLoadType;
             mURIResultedInDocument = true;
 
             /* we need to assign mLSHE to aSHEntry right here, so that on History loads,
              * SetCurrentURI() called from OnNewURI() will send proper
              * onLocationChange() notifications to the browser to update
              * back/forward buttons.
              */
