diff --git a/js/xpconnect/wrappers/AccessCheck.cpp b/js/xpconnect/wrappers/AccessCheck.cpp
--- a/js/xpconnect/wrappers/AccessCheck.cpp
+++ b/js/xpconnect/wrappers/AccessCheck.cpp
@@ -327,16 +327,23 @@ enum Access { READ = (1<<0), WRITE = (1<<1), NO_ACCESS = 0 };
 static bool
 IsInSandbox(JSContext *cx, JSObject *obj)
 {
     JSAutoCompartment ac(cx, obj);
     JSObject *global = JS_GetGlobalForObject(cx, obj);
     return !strcmp(js::GetObjectJSClass(global)->name, "Sandbox");
 }
 
+static void
+EnterAndThrow(JSContext *cx, JSObject *wrapper, const char *msg)
+{
+    JSAutoCompartment ac(cx, wrapper);
+    JS_ReportError(cx, msg);
+}
+
 bool
 ExposedPropertiesOnly::check(JSContext *cx, JSObject *wrapper, jsid id, Wrapper::Action act)
 {
     JSObject *wrappedObject = Wrapper::wrappedObject(wrapper);
 
     if (act == Wrapper::CALL)
         return true;
 
@@ -392,68 +399,68 @@ ExposedPropertiesOnly::check(JSContext *cx, JSObject *wrapper, jsid id, Wrapper:
     JS::Value exposedProps;
     if (!JS_LookupPropertyById(cx, wrappedObject, exposedPropsId, &exposedProps))
         return false;
 
     if (exposedProps.isNullOrUndefined())
         return false;
 
     if (!exposedProps.isObject()) {
-        JS_ReportError(cx, "__exposedProps__ must be undefined, null, or an Object");
+        EnterAndThrow(cx, wrapper, "__exposedProps__ must be undefined, null, or an Object");
         return false;
     }
 
     JSObject *hallpass = &exposedProps.toObject();
 
     Access access = NO_ACCESS;
 
     JSPropertyDescriptor desc;
     if (!JS_GetPropertyDescriptorById(cx, hallpass, id, JSRESOLVE_QUALIFIED, &desc)) {
         return false; // Error
     }
     if (!desc.obj || !(desc.attrs & JSPROP_ENUMERATE))
         return false;
 
     if (!JSVAL_IS_STRING(desc.value)) {
-        JS_ReportError(cx, "property must be a string");
+        EnterAndThrow(cx, wrapper, "property must be a string");
         return false;
     }
 
     JSString *str = JSVAL_TO_STRING(desc.value);
     size_t length;
     const jschar *chars = JS_GetStringCharsAndLength(cx, str, &length);
     if (!chars)
         return false;
 
     for (size_t i = 0; i < length; ++i) {
         switch (chars[i]) {
         case 'r':
             if (access & READ) {
-                JS_ReportError(cx, "duplicate 'readable' property flag");
+                EnterAndThrow(cx, wrapper, "duplicate 'readable' property flag");
                 return false;
             }
             access = Access(access | READ);
             break;
 
         case 'w':
             if (access & WRITE) {
-                JS_ReportError(cx, "duplicate 'writable' property flag");
+                EnterAndThrow(cx, wrapper, "duplicate 'writable' property flag");
                 return false;
             }
             access = Access(access | WRITE);
             break;
 
         default:
-            JS_ReportError(cx, "properties can only be readable or read and writable");
+            EnterAndThrow(cx, wrapper, "properties can only be readable or read and writable");
             return false;
         }
     }
 
     if (access == NO_ACCESS) {
-        JS_ReportError(cx, "specified properties must have a permission bit set");
+        EnterAndThrow(cx, wrapper, "specified properties must have a permission bit set");
         return false;
     }
 
     if ((act == Wrapper::SET && !(access & WRITE)) ||
         (act != Wrapper::SET && !(access & READ))) {
         return false;
     }
