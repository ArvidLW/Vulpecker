diff --git a/layout/generic/nsPlaceholderFrame.cpp b/layout/generic/nsPlaceholderFrame.cpp
--- a/layout/generic/nsPlaceholderFrame.cpp
+++ b/layout/generic/nsPlaceholderFrame.cpp
@@ -77,33 +77,45 @@ nsPlaceholderFrame::AddInlineMinWidth(ns
 {
   // Override AddInlineMinWith so that *nothing* happens.  In
   // particular, we don't want to zero out |aData->trailingWhitespace|,
   // since nsLineLayout skips placeholders when trimming trailing
   // whitespace, and we don't want to set aData->skipWhitespace to
   // false.
 
   // ...but push floats onto the list
-  if (mOutOfFlowFrame->GetStyleDisplay()->IsFloating())
+  if (mOutOfFlowFrame->GetStyleDisplay()->IsFloating()) {
     aData->floats.AppendElement(mOutOfFlowFrame);
+  }
+  if (mOutOfFlowFrame->CanContinueTextRun()) {
+    // Make sure the first-letter child text frame creates its text run.
+    nsIFrame::InlineMinWidthData discard = *aData;
+    mOutOfFlowFrame->AddInlineMinWidth(aRenderingContext, &discard);
+  }
 }
 
 /* virtual */ void
 nsPlaceholderFrame::AddInlinePrefWidth(nsRenderingContext *aRenderingContext,
                                        nsIFrame::InlinePrefWidthData *aData)
 {
   // Override AddInlinePrefWith so that *nothing* happens.  In
   // particular, we don't want to zero out |aData->trailingWhitespace|,
   // since nsLineLayout skips placeholders when trimming trailing
   // whitespace, and we don't want to set aData->skipWhitespace to
   // false.
 
   // ...but push floats onto the list
-  if (mOutOfFlowFrame->GetStyleDisplay()->IsFloating())
+  if (mOutOfFlowFrame->GetStyleDisplay()->IsFloating()) {
     aData->floats.AppendElement(mOutOfFlowFrame);
+  }
+  if (mOutOfFlowFrame->CanContinueTextRun()) {
+    // Make sure the first-letter child text frame creates its text run.
+    nsIFrame::InlinePrefWidthData discard = *aData;
+    mOutOfFlowFrame->AddInlinePrefWidth(aRenderingContext, &discard);
+  }
 }
 
 NS_IMETHODIMP
 nsPlaceholderFrame::Reflow(nsPresContext*          aPresContext,
                            nsHTMLReflowMetrics&     aDesiredSize,
                            const nsHTMLReflowState& aReflowState,
                            nsReflowStatus&          aStatus)
 {
diff --git a/layout/generic/nsTextFrameThebes.cpp b/layout/generic/nsTextFrameThebes.cpp
--- a/layout/generic/nsTextFrameThebes.cpp
+++ b/layout/generic/nsTextFrameThebes.cpp
@@ -6630,16 +6630,17 @@ nsTextFrame::AddInlineMinWidthForFlow(ns
     hyphBreakBefore = hyphBuffer.AppendElements(flowEndInTextRun - start);
     if (hyphBreakBefore) {
       provider.GetHyphenationBreaks(start, flowEndInTextRun - start,
                                     hyphBreakBefore);
     }
   }
 
   for (PRUint32 i = start, wordStart = start; i <= flowEndInTextRun; ++i) {
+    MOZ_ASSERT(textRun == GetTextRun(aTextRunType), "using destroyed textRun?");
     bool preformattedNewline = false;
     bool preformattedTab = false;
     if (i < flowEndInTextRun) {
       // XXXldb Shouldn't we be including the newline as part of the
       // segment that it ends rather than part of the segment that it
       // starts?
       preformattedNewline = preformatNewlines && textRun->CharIsNewline(i);
       preformattedTab = preformatTabs && textRun->CharIsTab(i);
@@ -6689,19 +6690,24 @@ nsTextFrame::AddInlineMinWidthForFlow(ns
          (textRun->GetFlags() & nsTextFrameUtils::TEXT_HAS_TRAILING_BREAK))) {
       if (preformattedNewline) {
         aData->ForceBreak(aRenderingContext);
       } else if (i < flowEndInTextRun && hyphBreakBefore &&
                  hyphBreakBefore[i - start])
       {
         aData->OptionallyBreak(aRenderingContext, 
                                NSToCoordRound(provider.GetHyphenWidth()));
-      } {
+      } else {
         aData->OptionallyBreak(aRenderingContext);
       }
+
+      if (textRun != GetTextRun(aTextRunType)) {
+        NS_ERROR("textRun was destroyed?");
+        return;
+      }
       wordStart = i;
     }
   }
 
   if (start < flowEndInTextRun) {
     // Check if we have collapsible whitespace at the end
     aData->skipWhitespace =
       IsTrimmableSpace(provider.GetFragment(),
@@ -6781,16 +6787,17 @@ nsTextFrame::AddInlinePrefWidthForFlow(n
   PRUint32 start =
     FindStartAfterSkippingWhitespace(&provider, aData, textStyle, &iter, flowEndInTextRun);
 
   // XXX Should we consider hyphenation here?
   // If newlines and tabs aren't preformatted, nothing to do inside
   // the loop so make i skip to the end
   PRUint32 loopStart = (preformatNewlines || preformatTabs) ? start : flowEndInTextRun;
   for (PRUint32 i = loopStart, lineStart = start; i <= flowEndInTextRun; ++i) {
+    MOZ_ASSERT(textRun == GetTextRun(aTextRunType), "using destroyed textRun?");
     bool preformattedNewline = false;
     bool preformattedTab = false;
     if (i < flowEndInTextRun) {
       // XXXldb Shouldn't we be including the newline as part of the
       // segment that it ends rather than part of the segment that it
       // starts?
       NS_ASSERTION(preformatNewlines, "We can't be here unless newlines are hard breaks");
       preformattedNewline = preformatNewlines && textRun->CharIsNewline(i);
@@ -6829,16 +6836,20 @@ nsTextFrame::AddInlinePrefWidthForFlow(n
       gfxFloat afterTab =
         AdvanceToNextTab(aData->currentLine, this,
                          textRun, &tabWidth);
       aData->currentLine = nscoord(afterTab + spacing.mAfter);
       lineStart = i + 1;
     } else if (preformattedNewline) {
       aData->ForceBreak(aRenderingContext);
       lineStart = i;
+      if (textRun != GetTextRun(aTextRunType)) {
+        NS_ERROR("textRun was destroyed?");
+        return;
+      }
     }
   }
 
   // Check if we have collapsible whitespace at the end
   if (start < flowEndInTextRun) {
     aData->skipWhitespace =
       IsTrimmableSpace(provider.GetFragment(),
                        iter.ConvertSkippedToOriginal(flowEndInTextRun - 1),
