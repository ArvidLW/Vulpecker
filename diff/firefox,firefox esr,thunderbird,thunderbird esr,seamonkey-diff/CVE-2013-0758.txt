diff --git a/dom/plugins/base/nsPluginHost.cpp b/dom/plugins/base/nsPluginHost.cpp
--- a/dom/plugins/base/nsPluginHost.cpp
+++ b/dom/plugins/base/nsPluginHost.cpp
@@ -3087,38 +3087,36 @@ nsresult nsPluginHost::NewPluginURLStrea
 {
   nsCOMPtr<nsIURI> url;
   nsAutoString absUrl;
   nsresult rv;
 
   if (aURL.Length() <= 0)
     return NS_OK;
 
-  // get the full URL of the document that the plugin is embedded
-  //   in to create an absolute url in case aURL is relative
-  nsCOMPtr<nsIDocument> doc;
+  // get the base URI for the plugin to create an absolute url 
+  // in case aURL is relative
   nsRefPtr<nsPluginInstanceOwner> owner = aInstance->GetOwner();
   if (owner) {
-    rv = owner->GetDocument(getter_AddRefs(doc));
-    if (NS_SUCCEEDED(rv) && doc) {
-      // Create an absolute URL
-      rv = NS_MakeAbsoluteURI(absUrl, aURL, doc->GetDocBaseURI());
-    }
+    rv = NS_MakeAbsoluteURI(absUrl, aURL, nsCOMPtr<nsIURI>(owner->GetBaseURI()));
   }
 
   if (absUrl.IsEmpty())
     absUrl.Assign(aURL);
 
   rv = NS_NewURI(getter_AddRefs(url), absUrl);
   if (NS_FAILED(rv))
     return rv;
 
   nsCOMPtr<nsIDOMElement> element;
-  if (owner)
+  nsCOMPtr<nsIDocument> doc;
+  if (owner) {
     owner->GetDOMElement(getter_AddRefs(element));
+    owner->GetDocument(getter_AddRefs(doc));
+  }
 
   int16_t shouldLoad = nsIContentPolicy::ACCEPT;
   rv = NS_CheckContentLoadPolicy(nsIContentPolicy::TYPE_OBJECT_SUBREQUEST,
                                  url,
                                  (doc ? doc->NodePrincipal() : nullptr),
                                  element,
                                  EmptyCString(), //mime guess
                                  nullptr,         //extra
@@ -3170,18 +3168,22 @@ nsresult nsPluginHost::NewPluginURLStrea
       // bug 724465.
       nsCOMPtr<nsIURI> referer;
 
       nsCOMPtr<nsIObjectLoadingContent> olc = do_QueryInterface(element);
       if (olc)
         olc->GetSrcURI(getter_AddRefs(referer));
 
 
-      if (!referer)
+      if (!referer) {
+        if (!doc) {
+          return NS_ERROR_FAILURE;
+        }
         referer = doc->GetDocumentURI();
+      }
 
       rv = httpChannel->SetReferrer(referer);
       NS_ENSURE_SUCCESS(rv,rv);
     }
       
     if (aPostStream) {
       // XXX it's a bit of a hack to rewind the postdata stream
       // here but it has to be done in case the post data is
@@ -3211,32 +3213,36 @@ nsresult nsPluginHost::NewPluginURLStrea
 // Called by GetURL and PostURL
 nsresult
 nsPluginHost::DoURLLoadSecurityCheck(nsNPAPIPluginInstance *aInstance,
                                      const char* aURL)
 {
   if (!aURL || *aURL == '\0')
     return NS_OK;
 
-  // get the URL of the document that loaded the plugin
+  // get the base URI for the plugin element
   nsRefPtr<nsPluginInstanceOwner> owner = aInstance->GetOwner();
   if (!owner)
     return NS_ERROR_FAILURE;
 
+  nsCOMPtr<nsIURI> baseURI = owner->GetBaseURI();
+  if (!baseURI)
+    return NS_ERROR_FAILURE;
+
+  // Create an absolute URL for the target in case the target is relative
+  nsCOMPtr<nsIURI> targetURL;
+  NS_NewURI(getter_AddRefs(targetURL), aURL, baseURI);
+  if (!targetURL)
+    return NS_ERROR_FAILURE;
+
   nsCOMPtr<nsIDocument> doc;
   owner->GetDocument(getter_AddRefs(doc));
   if (!doc)
     return NS_ERROR_FAILURE;
 
-  // Create an absolute URL for the target in case the target is relative
-  nsCOMPtr<nsIURI> targetURL;
-  NS_NewURI(getter_AddRefs(targetURL), aURL, doc->GetDocBaseURI());
-  if (!targetURL)
-    return NS_ERROR_FAILURE;
-
   nsresult rv;
   nsCOMPtr<nsIScriptSecurityManager> secMan(
     do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv));
   if (NS_FAILED(rv))
     return rv;
 
   return secMan->CheckLoadURIWithPrincipal(doc->NodePrincipal(), targetURL,
                                            nsIScriptSecurityManager::STANDARD);
diff --git a/dom/plugins/base/nsPluginInstanceOwner.cpp b/dom/plugins/base/nsPluginInstanceOwner.cpp
--- a/dom/plugins/base/nsPluginInstanceOwner.cpp
+++ b/dom/plugins/base/nsPluginInstanceOwner.cpp
@@ -532,17 +532,17 @@ NS_IMETHODIMP nsPluginInstanceOwner::Get
   nsCOMPtr<nsISupports> container = presContext->GetContainer();
   NS_ENSURE_TRUE(container,NS_ERROR_FAILURE);
   nsCOMPtr<nsILinkHandler> lh = do_QueryInterface(container);
   NS_ENSURE_TRUE(lh, NS_ERROR_FAILURE);
 
   nsAutoString  unitarget;
   unitarget.AssignASCII(aTarget); // XXX could this be nonascii?
 
-  nsCOMPtr<nsIURI> baseURI = mContent->GetBaseURI();
+  nsCOMPtr<nsIURI> baseURI = GetBaseURI();
 
   // Create an absolute URL
   nsCOMPtr<nsIURI> uri;
   nsresult rv = NS_NewURI(getter_AddRefs(uri), aURL, baseURI);
 
   NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
 
   nsCOMPtr<nsIInputStream> headersDataStream;
@@ -909,17 +909,17 @@ NS_IMETHODIMP nsPluginInstanceOwner::Get
     if (0 == PL_strcasecmp(mCachedAttrParamNames[i], name)) {
       *result = mCachedAttrParamValues[i];
       return NS_OK;
     }
   }
 
   return NS_ERROR_FAILURE;
 }
-  
+
 NS_IMETHODIMP nsPluginInstanceOwner::GetDocumentBase(const char* *result)
 {
   NS_ENSURE_ARG_POINTER(result);
   nsresult rv = NS_OK;
   if (mDocumentBase.IsEmpty()) {
     if (!mObjectFrame) {
       *result = nullptr;
       return NS_ERROR_FAILURE;
@@ -3473,29 +3473,37 @@ nsObjectFrame* nsPluginInstanceOwner::Ge
   return mObjectFrame;
 }
 
 // Little helper function to resolve relative URL in
 // |value| for certain inputs of |name|
 void nsPluginInstanceOwner::FixUpURLS(const nsString &name, nsAString &value)
 {
   if (name.LowerCaseEqualsLiteral("pluginspage")) {
-    nsCOMPtr<nsIURI> baseURI = mContent->GetBaseURI();
+    nsCOMPtr<nsIURI> baseURI = GetBaseURI();
     nsAutoString newURL;
     NS_MakeAbsoluteURI(newURL, value, baseURI);
     if (!newURL.IsEmpty())
       value = newURL;
   }
 }
 
 NS_IMETHODIMP nsPluginInstanceOwner::PrivateModeChanged(bool aEnabled)
 {
   return mInstance ? mInstance->PrivateModeStateChanged(aEnabled) : NS_OK;
 }
 
+already_AddRefed<nsIURI> nsPluginInstanceOwner::GetBaseURI() const
+{
+  if (!mContent) {
+    return nullptr;
+  }
+  return mContent->GetBaseURI();
+}
+
 // nsPluginDOMContextMenuListener class implementation
 
 nsPluginDOMContextMenuListener::nsPluginDOMContextMenuListener()
 {
 }
 
 nsPluginDOMContextMenuListener::~nsPluginDOMContextMenuListener()
 {
diff --git a/dom/plugins/base/nsPluginInstanceOwner.h b/dom/plugins/base/nsPluginInstanceOwner.h
--- a/dom/plugins/base/nsPluginInstanceOwner.h
+++ b/dom/plugins/base/nsPluginInstanceOwner.h
@@ -226,16 +226,18 @@ public:
   // The eventual target of these operations is PluginInstanceParent,
   // but it takes several hops to get there.
   void SetBackgroundUnknown();
   already_AddRefed<gfxContext> BeginUpdateBackground(const nsIntRect& aRect);
   void EndUpdateBackground(gfxContext* aContext, const nsIntRect& aRect);
   
   bool UseAsyncRendering();
 
+  already_AddRefed<nsIURI> GetBaseURI() const;
+
 #ifdef MOZ_WIDGET_ANDROID
   // Returns the image container for the specified VideoInfo
   void GetVideos(nsTArray<nsNPAPIPluginInstance::VideoInfo*>& aVideos);
   already_AddRefed<mozilla::layers::ImageContainer> GetImageContainerForVideo(nsNPAPIPluginInstance::VideoInfo* aVideoInfo);
 
   void Invalidate();
 
   void RequestFullScreen();
