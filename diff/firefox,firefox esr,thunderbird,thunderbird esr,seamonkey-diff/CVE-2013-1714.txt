diff --git a/content/base/src/nsXMLHttpRequest.cpp b/content/base/src/nsXMLHttpRequest.cpp
--- a/content/base/src/nsXMLHttpRequest.cpp
+++ b/content/base/src/nsXMLHttpRequest.cpp
@@ -395,17 +395,17 @@ nsXMLHttpRequest::InitParameters(bool aA
   // Check for permissions.
   nsCOMPtr<nsPIDOMWindow> window = do_QueryInterface(GetOwner());
   if (!window || !window->GetDocShell()) {
     return;
   }
 
   // Chrome is always allowed access, so do the permission check only
   // for non-chrome pages.
-  if (!nsContentUtils::IsCallerChrome()) {
+  if (!IsSystemXHR()) {
     nsCOMPtr<nsIDocument> doc = window->GetExtantDoc();
     if (!doc) {
       return;
     }
 
     nsCOMPtr<nsIPrincipal> principal = doc->NodePrincipal();
     nsCOMPtr<nsIPermissionManager> permMgr =
       do_GetService(NS_PERMISSIONMANAGER_CONTRACTID);
@@ -1229,17 +1229,17 @@ nsXMLHttpRequest::SlowAbort()
 }
 
 /*Method that checks if it is safe to expose a header value to the client.
 It is used to check what headers are exposed for CORS requests.*/
 bool
 nsXMLHttpRequest::IsSafeHeader(const nsACString& header, nsIHttpChannel* httpChannel)
 {
   // See bug #380418. Hide "Set-Cookie" headers from non-chrome scripts.
-  if (!nsContentUtils::IsCallerChrome() &&
+  if (!IsSystemXHR() &&
        (header.LowerCaseEqualsASCII("set-cookie") ||
         header.LowerCaseEqualsASCII("set-cookie2"))) {
     NS_WARNING("blocked access to response header");
     return false;
   }
   // if this is not a CORS call all headers are safe
   if (!(mState & XML_HTTP_REQUEST_USE_XSITE_AC)){
     return true;
@@ -2994,32 +2994,32 @@ nsXMLHttpRequest::SetRequestHeader(const
   // or
   // 2 - we have not yet explicitly set that header; this allows web
   //     content to override default headers the first time they set them.
   bool mergeHeaders = true;
 
   // Prevent modification to certain HTTP headers (see bug 302263), unless
   // the executing script is privileged.
   bool isInvalidHeader = false;
-  const char *kInvalidHeaders[] = {
+  static const char *kInvalidHeaders[] = {
     "accept-charset", "accept-encoding", "access-control-request-headers",
     "access-control-request-method", "connection", "content-length",
     "cookie", "cookie2", "content-transfer-encoding", "date", "dnt",
     "expect", "host", "keep-alive", "origin", "referer", "te", "trailer",
     "transfer-encoding", "upgrade", "user-agent", "via"
   };
   uint32_t i;
   for (i = 0; i < ArrayLength(kInvalidHeaders); ++i) {
     if (header.LowerCaseEqualsASCII(kInvalidHeaders[i])) {
       isInvalidHeader = true;
       break;
     }
   }
 
-  if (!nsContentUtils::IsCallerChrome()) {
+  if (!IsSystemXHR()) {
     // Step 5: Check for dangerous headers.
     if (isInvalidHeader) {
       NS_WARNING("refusing to set request header");
       return NS_OK;
     }
     if (StringBeginsWith(header, NS_LITERAL_CSTRING("proxy-"),
                          nsCaseInsensitiveCStringComparator()) ||
         StringBeginsWith(header, NS_LITERAL_CSTRING("sec-"),
@@ -3199,17 +3199,17 @@ nsXMLHttpRequest::SetMozBackgroundReques
   nsresult rv = NS_OK;
   SetMozBackgroundRequest(aMozBackgroundRequest, rv);
   return rv;
 }
 
 void
 nsXMLHttpRequest::SetMozBackgroundRequest(bool aMozBackgroundRequest, nsresult& aRv)
 {
-  if (!nsContentUtils::IsCallerChrome()) {
+  if (!IsSystemXHR()) {
     aRv = NS_ERROR_DOM_SECURITY_ERR;
     return;
   }
 
   if (!(mState & XML_HTTP_REQUEST_UNSENT)) {
     // Can't change this while we're in the middle of something.
     aRv = NS_ERROR_IN_PROGRESS;
     return;