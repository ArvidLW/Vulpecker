diff --git a/content/xbl/src/nsXBLBinding.cpp b/content/xbl/src/nsXBLBinding.cpp
--- a/content/xbl/src/nsXBLBinding.cpp
+++ b/content/xbl/src/nsXBLBinding.cpp
@@ -346,43 +346,48 @@ XBLEnumerate(JSContext *cx, JS::Handle<J
 {
   nsXBLPrototypeBinding* protoBinding =
     static_cast<nsXBLPrototypeBinding*>(::JS_GetReservedSlot(obj, 0).toPrivate());
   MOZ_ASSERT(protoBinding);
 
   return protoBinding->ResolveAllFields(cx, obj);
 }
 
-nsXBLJSClass::nsXBLJSClass(const nsAFlatCString& aClassName)
+uint64_t nsXBLJSClass::sIdCount = 0;
+
+nsXBLJSClass::nsXBLJSClass(const nsAFlatCString& aClassName,
+                           const nsCString& aKey)
 {
   memset(this, 0, sizeof(nsXBLJSClass));
   next = prev = static_cast<JSCList*>(this);
   name = ToNewCString(aClassName);
   flags =
     JSCLASS_HAS_PRIVATE | JSCLASS_PRIVATE_IS_NSISUPPORTS |
     JSCLASS_NEW_RESOLVE |
     // Our one reserved slot holds the relevant nsXBLPrototypeBinding
     JSCLASS_HAS_RESERVED_SLOTS(1);
   addProperty = delProperty = getProperty = ::JS_PropertyStub;
   setProperty = ::JS_StrictPropertyStub;
   enumerate = XBLEnumerate;
   resolve = (JSResolveOp)XBLResolve;
   convert = ::JS_ConvertStub;
   finalize = XBLFinalize;
+  mKey = aKey;
 }
 
 nsrefcnt
 nsXBLJSClass::Destroy()
 {
   NS_ASSERTION(next == prev && prev == static_cast<JSCList*>(this),
                "referenced nsXBLJSClass is on LRU list already!?");
 
   if (nsXBLService::gClassTable) {
-    nsCStringKey key(name);
+    nsCStringKey key(mKey);
     (nsXBLService::gClassTable)->Remove(&key);
+    mKey.Truncate();
   }
 
   if (nsXBLService::gClassLRUListLength >= nsXBLService::gClassLRUListQuota) {
     // Over LRU list quota, just unhash and delete this class.
     delete this;
   } else {
     // Put this most-recently-used class on end of the LRU-sorted freelist.
     JSCList* mru = static_cast<JSCList*>(this);
@@ -1352,88 +1357,102 @@ nsXBLBinding::WalkRules(nsIStyleRuleProc
 nsresult
 nsXBLBinding::DoInitJSClass(JSContext *cx, JSObject *global, JSObject *obj,
                             const nsAFlatCString& aClassName,
                             nsXBLPrototypeBinding* aProtoBinding,
                             JSObject** aClassObject)
 {
   // First ensure our JS class is initialized.
   nsAutoCString className(aClassName);
+  nsAutoCString xblKey(aClassName);
   JSObject* parent_proto = nullptr;  // If we have an "obj" we can set this
   JSAutoRequest ar(cx);
 
   JSAutoCompartment ac(cx, global);
-
+  nsXBLJSClass* c = nullptr;
   if (obj) {
     // Retrieve the current prototype of obj.
     if (!JS_GetPrototype(cx, obj, &parent_proto)) {
       return NS_ERROR_FAILURE;
     }
     if (parent_proto) {
       // We need to create a unique classname based on aClassName and
-      // parent_proto.  Append a space (an invalid URI character) to ensure that
+      // id.  Append a space (an invalid URI character) to ensure that
       // we don't have accidental collisions with the case when parent_proto is
       // null and aClassName ends in some bizarre numbers (yeah, it's unlikely).
       jsid parent_proto_id;
       if (!::JS_GetObjectId(cx, parent_proto, &parent_proto_id)) {
         // Probably OOM
         return NS_ERROR_OUT_OF_MEMORY;
       }
 
       // One space, maybe "0x", at most 16 chars (on a 64-bit system) of long,
       // and a null-terminator (which PR_snprintf ensures is there even if the
       // string representation of what we're printing does not fit in the buffer
       // provided).
       char buf[20];
-      PR_snprintf(buf, sizeof(buf), " %lx", parent_proto_id);
-      className.Append(buf);
+      if (sizeof(jsid) == 4) {
+        PR_snprintf(buf, sizeof(buf), " %lx", parent_proto_id);
+      } else {
+        MOZ_ASSERT(sizeof(jsid) == 8);
+        PR_snprintf(buf, sizeof(buf), " %llx", parent_proto_id);
+      }
+      xblKey.Append(buf);
+      nsCStringKey key(xblKey);
+
+      c = static_cast<nsXBLJSClass*>(nsXBLService::gClassTable->Get(&key));
+      if (c) {
+        className.Assign(c->name);
+      } else {
+        char buf[20];
+        PR_snprintf(buf, sizeof(buf), " %llx", nsXBLJSClass::NewId());
+        className.Append(buf);
+      }
     }
   }
 
   jsval val;
   JSObject* proto = NULL;
   if ((!::JS_LookupPropertyWithFlags(cx, global, className.get(), 0, &val)) ||
       JSVAL_IS_PRIMITIVE(val)) {
     // We need to initialize the class.
 
-    nsXBLJSClass* c;
-    void* classObject;
-    nsCStringKey key(className);
-    classObject = (nsXBLService::gClassTable)->Get(&key);
-
-    if (classObject) {
-      c = static_cast<nsXBLJSClass*>(classObject);
-
+    nsCStringKey key(xblKey);
+    if (!c) {
+      c = static_cast<nsXBLJSClass*>(nsXBLService::gClassTable->Get(&key));
+    }
+    if (c) {
       // If c is on the LRU list (i.e., not linked to itself), remove it now!
       JSCList* link = static_cast<JSCList*>(c);
       if (c->next != link) {
         JS_REMOVE_AND_INIT_LINK(link);
         nsXBLService::gClassLRUListLength--;
       }
     } else {
       if (JS_CLIST_IS_EMPTY(&nsXBLService::gClassLRUList)) {
         // We need to create a struct for this class.
-        c = new nsXBLJSClass(className);
+        c = new nsXBLJSClass(className, xblKey);
 
         if (!c)
           return NS_ERROR_OUT_OF_MEMORY;
       } else {
         // Pull the least recently used class struct off the list.
         JSCList* lru = (nsXBLService::gClassLRUList).next;
         JS_REMOVE_AND_INIT_LINK(lru);
         nsXBLService::gClassLRUListLength--;
 
         // Remove any mapping from the old name to the class struct.
         c = static_cast<nsXBLJSClass*>(lru);
-        nsCStringKey oldKey(c->name);
+        nsCStringKey oldKey(c->Key());
         (nsXBLService::gClassTable)->Remove(&oldKey);
 
         // Change the class name and we're done.
         nsMemory::Free((void*) c->name);
         c->name = ToNewCString(className);
+        c->SetKey(xblKey);
       }
 
       // Add c to our table.
       (nsXBLService::gClassTable)->Put(&key, (void*)c);
     }
 
     // The prototype holds a strong reference to its class struct.
     c->Hold();
diff --git a/content/xbl/src/nsXBLService.h b/content/xbl/src/nsXBLService.h
--- a/content/xbl/src/nsXBLService.h
+++ b/content/xbl/src/nsXBLService.h
@@ -129,19 +129,26 @@ public:
 
   nsFixedSizeAllocator mPool;
 };
 
 class nsXBLJSClass : public JSCList, public JSClass
 {
 private:
   nsrefcnt mRefCnt;
+  nsCString mKey;
+  static uint64_t sIdCount;
   nsrefcnt Destroy();
 
 public:
-  nsXBLJSClass(const nsAFlatCString& aClassName);
+  nsXBLJSClass(const nsAFlatCString& aClassName, const nsCString& aKey);
   ~nsXBLJSClass() { nsMemory::Free((void*) name); }
 
+  static uint64_t NewId() { return ++sIdCount; }
+
+  nsCString& Key() { return mKey; }
+  void SetKey(const nsCString& aKey) { mKey = aKey; }
+
   nsrefcnt Hold() { return ++mRefCnt; }
   nsrefcnt Drop() { return --mRefCnt ? mRefCnt : Destroy(); }
 };
 
 #endif