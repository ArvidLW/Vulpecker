diff --git a/layout/generic/nsObjectFrame.cpp b/layout/generic/nsObjectFrame.cpp
--- a/layout/generic/nsObjectFrame.cpp
+++ b/layout/generic/nsObjectFrame.cpp
@@ -3137,80 +3137,81 @@ nsresult nsPluginInstanceOwner::EnsureCa
   else 
     mNumCachedParams = 0xFFFF;
 
   // Some plugins were never written to understand the "data" attribute of the OBJECT tag.
   // Real and WMP will not play unless they find a "src" attribute, see bug 152334.
   // Nav 4.x would simply replace the "data" with "src". Because some plugins correctly
   // look for "data", lets instead copy the "data" attribute and add another entry
   // to the bottom of the array if there isn't already a "src" specified.
-  PRInt16 numRealAttrs = mNumCachedAttrs;
+  PRUint16 numRealAttrs = mNumCachedAttrs;
   nsAutoString data;
   if (mContent->Tag() == nsGkAtoms::object
     && !mContent->HasAttr(kNameSpaceID_None, nsGkAtoms::src)
     && mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::data, data)) {
       mNumCachedAttrs++;
   }
 
   // now lets make the arrays
   mCachedAttrParamNames  = (char **)PR_Calloc(sizeof(char *) * (mNumCachedAttrs + 1 + mNumCachedParams), 1);
   NS_ENSURE_TRUE(mCachedAttrParamNames,  NS_ERROR_OUT_OF_MEMORY);
   mCachedAttrParamValues = (char **)PR_Calloc(sizeof(char *) * (mNumCachedAttrs + 1 + mNumCachedParams), 1);
   NS_ENSURE_TRUE(mCachedAttrParamValues, NS_ERROR_OUT_OF_MEMORY);
 
   // let's fill in our attributes
-  PRInt16 c = 0;
+  PRUint32 nextAttrParamIndex = 0;
 
   // Some plugins (eg Flash, see bug 234675.) are actually sensitive to the
   // attribute order.  So we want to make sure we give the plugin the
   // attributes in the order they came in in the source, to be compatible with
   // other browsers.  Now in HTML, the storage order is the reverse of the
   // source order, while in XML and XHTML it's the same as the source order
   // (see the AddAttributes functions in the HTML and XML content sinks).
-  PRInt16 start, end, increment;
+  PRInt32 start, end, increment;
   if (mContent->IsNodeOfType(nsINode::eHTML) &&
       mContent->NodeInfo()->NamespaceEquals(kNameSpaceID_None)) {
     // HTML.  Walk attributes in reverse order.
     start = numRealAttrs - 1;
     end = -1;
     increment = -1;
   } else {
     // XHTML or XML.  Walk attributes in forward order.
     start = 0;
     end = numRealAttrs;
     increment = 1;
   }
-  for (PRInt16 index = start; index != end; index += increment) {
+  for (PRInt32 index = start; index != end; index += increment) {
     const nsAttrName* attrName = mContent->GetAttrNameAt(index);
     nsIAtom* atom = attrName->LocalName();
     nsAutoString value;
     mContent->GetAttr(attrName->NamespaceID(), atom, value);
     nsAutoString name;
     atom->ToString(name);
 
     FixUpURLS(name, value);
 
-    mCachedAttrParamNames [c] = ToNewUTF8String(name);
-    mCachedAttrParamValues[c] = ToNewUTF8String(value);
-    c++;
+    mCachedAttrParamNames [nextAttrParamIndex] = ToNewUTF8String(name);
+    mCachedAttrParamValues[nextAttrParamIndex] = ToNewUTF8String(value);
+    nextAttrParamIndex++;
   }
 
   // if the conditions above were met, copy the "data" attribute to a "src" array entry
   if (data.Length()) {
-    mCachedAttrParamNames [mNumCachedAttrs-1] = ToNewUTF8String(NS_LITERAL_STRING("SRC"));
-    mCachedAttrParamValues[mNumCachedAttrs-1] = ToNewUTF8String(data);
+    mCachedAttrParamNames [nextAttrParamIndex] = ToNewUTF8String(NS_LITERAL_STRING("SRC"));
+    mCachedAttrParamValues[nextAttrParamIndex] = ToNewUTF8String(data);
+    nextAttrParamIndex++;
   }
 
   // add our PARAM and null separator
-  mCachedAttrParamNames [mNumCachedAttrs] = ToNewUTF8String(NS_LITERAL_STRING("PARAM"));
-  mCachedAttrParamValues[mNumCachedAttrs] = nsnull;
+  mCachedAttrParamNames [nextAttrParamIndex] = ToNewUTF8String(NS_LITERAL_STRING("PARAM"));
+  mCachedAttrParamValues[nextAttrParamIndex] = nsnull;
+  nextAttrParamIndex++;
 
   // now fill in the PARAM name/value pairs from the cached DOM nodes
-  c = 0;
-  for (PRInt16 idx = 0; idx < mNumCachedParams; idx++) {
+  for (PRUint16 idx = 0; idx < mNumCachedParams; idx++) {
     nsIDOMElement* param = ourParams.ObjectAt(idx);
     if (param) {
      nsAutoString name;
      nsAutoString value;
      param->GetAttribute(NS_LITERAL_STRING("name"), name); // check for empty done above
      param->GetAttribute(NS_LITERAL_STRING("value"), value);
 
      FixUpURLS(name, value);
@@ -3222,19 +3223,19 @@ nsresult nsPluginInstanceOwner::EnsureCa
       * white space in CDATA attribute values (e.g., "
       * myval " may be interpreted as "myval"). Authors
       * should not declare attribute values with
       * leading or trailing white space.''
       * However, do not trim consecutive spaces as in bug 122119
       */            
      name.Trim(" \n\r\t\b", PR_TRUE, PR_TRUE, PR_FALSE);
      value.Trim(" \n\r\t\b", PR_TRUE, PR_TRUE, PR_FALSE);
-     mCachedAttrParamNames [mNumCachedAttrs + 1 + c] = ToNewUTF8String(name);
-     mCachedAttrParamValues[mNumCachedAttrs + 1 + c] = ToNewUTF8String(value);
-     c++;                                                      // rules!
+     mCachedAttrParamNames [nextAttrParamIndex] = ToNewUTF8String(name);
+     mCachedAttrParamValues[nextAttrParamIndex] = ToNewUTF8String(value);
+     nextAttrParamIndex++;
     }
   }
 
   return NS_OK;
 }
 
 
 // Here's where we forward events to plugins.
