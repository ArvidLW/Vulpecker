--- xpcom/io/nsUnicharInputStream.cpp	8 Jul 2007 07:08:51 -0000	3.51
+++ xpcom/io/nsUnicharInputStream.cpp	5 Mar 2008 07:33:28 -0000
@@ -218,23 +218,24 @@ nsresult UTF8InputStream::Close()
 nsresult UTF8InputStream::Read(PRUnichar* aBuf,
                                PRUint32 aCount,
                                PRUint32 *aReadCount)
 {
   NS_ASSERTION(mUnicharDataLength >= mUnicharDataOffset, "unsigned madness");
   PRUint32 readCount = mUnicharDataLength - mUnicharDataOffset;
   nsresult errorCode;
   if (0 == readCount) {
     // Fill the unichar buffer
-    readCount = Fill(&errorCode);
-    if (readCount <= 0) {
+    PRInt32 bytesRead = Fill(&errorCode);
+    if (bytesRead <= 0) {
       *aReadCount = 0;
       return errorCode;
     }
+    readCount = bytesRead;
   }
   if (readCount > aCount) {
     readCount = aCount;
   }
   memcpy(aBuf, mUnicharData->GetBuffer() + mUnicharDataOffset,
          readCount * sizeof(PRUnichar));
   mUnicharDataOffset += readCount;
   *aReadCount = readCount;
   return NS_OK;
@@ -244,23 +245,24 @@ NS_IMETHODIMP
 UTF8InputStream::ReadSegments(nsWriteUnicharSegmentFun aWriter,
                               void* aClosure,
                               PRUint32 aCount, PRUint32 *aReadCount)
 {
   NS_ASSERTION(mUnicharDataLength >= mUnicharDataOffset, "unsigned madness");
   PRUint32 bytesToWrite = mUnicharDataLength - mUnicharDataOffset;
   nsresult rv = NS_OK;
   if (0 == bytesToWrite) {
     // Fill the unichar buffer
-    bytesToWrite = Fill(&rv);
-    if (bytesToWrite <= 0) {
+    PRInt32 bytesRead = Fill(&rv);
+    if (bytesRead <= 0) {
       *aReadCount = 0;
       return rv;
     }
+    bytesToWrite = bytesRead;
   }
   
   if (bytesToWrite > aCount)
     bytesToWrite = aCount;
   
   PRUint32 bytesWritten;
   PRUint32 totalBytesWritten = 0;
 
   while (bytesToWrite) {
@@ -286,23 +288,24 @@ UTF8InputStream::ReadSegments(nsWriteUni
 NS_IMETHODIMP
 UTF8InputStream::ReadString(PRUint32 aCount, nsAString& aString,
                             PRUint32* aReadCount)
 {
   NS_ASSERTION(mUnicharDataLength >= mUnicharDataOffset, "unsigned madness");
   PRUint32 readCount = mUnicharDataLength - mUnicharDataOffset;
   nsresult errorCode;
   if (0 == readCount) {
     // Fill the unichar buffer
-    readCount = Fill(&errorCode);
-    if (readCount <= 0) {
+    PRInt32 bytesRead = Fill(&errorCode);
+    if (bytesRead <= 0) {
       *aReadCount = 0;
       return errorCode;
     }
+    readCount = bytesRead;
   }
   if (readCount > aCount) {
     readCount = aCount;
   }
   const PRUnichar* buf = reinterpret_cast<const PRUnichar*>(mUnicharData->GetBuffer() +
                                              mUnicharDataOffset);
   aString.Assign(buf, readCount);
 
   mUnicharDataOffset += readCount;
@@ -344,19 +347,22 @@ PRInt32 UTF8InputStream::Fill(nsresult *
                "Ouch. I would overflow my buffer if I wasn't so careful.");
   if (PRInt32(dstLen) > mUnicharData->GetBufferSize()) return 0;
   
   ConvertUTF8toUTF16 converter(mUnicharData->GetBuffer());
   
   nsASingleFragmentCString::const_char_iterator start = mByteData->GetBuffer();
   nsASingleFragmentCString::const_char_iterator end = mByteData->GetBuffer() + srcLen;
             
   copy_string(start, end, converter);
-  NS_ASSERTION(converter.Length() == dstLen, "length mismatch");
+  if (converter.Length() != dstLen) {
+    *aErrorCode = NS_BASE_STREAM_BAD_CONVERSION;
+    return -1;
+  }
                
   mUnicharDataOffset = 0;
   mUnicharDataLength = dstLen;
   mByteDataOffset = srcLen;
   
   return dstLen;
 }
 
 void
