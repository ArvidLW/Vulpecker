--- widget/src/gtk2/nsWindow.cpp	20 Dec 2006 09:05:19 -0000	1.198
+++ widget/src/gtk2/nsWindow.cpp	15 Jan 2007 21:08:13 -0000
@@ -953,41 +953,48 @@ nsWindow::SetCursor(imgIContainer* aCurs
     aCursor->GetFrameAt(0, getter_AddRefs(frame));
     if (!frame)
         return NS_ERROR_NOT_AVAILABLE;
 
     nsCOMPtr<nsIImage> img(do_GetInterface(frame));
     if (!img)
         return NS_ERROR_NOT_AVAILABLE;
 
     GdkPixbuf* pixbuf = nsImageToPixbuf::ImageToPixbuf(img);
     if (!pixbuf)
         return NS_ERROR_NOT_AVAILABLE;
 
+    int width = gdk_pixbuf_get_width(pixbuf);
+    int height = gdk_pixbuf_get_height(pixbuf);
+    // Reject cursors greater than 64 pixels in some direction, to prevent
+    // spoofing.
+    // XXX ideally we should rescale. Also, we could modify the API to
+    // allow trusted content to set larger cursors.
+    if (width > 64 || height > 64)
+        return NS_ERROR_NOT_AVAILABLE;
+
     // Looks like all cursors need an alpha channel (tested on Gtk 2.4.4). This
     // is of course not documented anywhere...
     // So add one if there isn't one yet
     if (!gdk_pixbuf_get_has_alpha(pixbuf)) {
         GdkPixbuf* alphaBuf = gdk_pixbuf_add_alpha(pixbuf, FALSE, 0, 0, 0);
         gdk_pixbuf_unref(pixbuf);
         if (!alphaBuf) {
             return NS_ERROR_OUT_OF_MEMORY;
         }
         pixbuf = alphaBuf;
     }
 
     GdkCursor* cursor;
     if (!_gdk_cursor_new_from_pixbuf || !_gdk_display_get_default) {
         // Fallback to a monochrome cursor
-        int width = gdk_pixbuf_get_width(pixbuf);
-        int height = gdk_pixbuf_get_height(pixbuf);
         GdkPixmap* mask = gdk_pixmap_new(NULL, width, height, 1);
         if (!mask)
             return NS_ERROR_OUT_OF_MEMORY;
 
         PRUint8* data = Data32BitTo1Bit(gdk_pixbuf_get_pixels(pixbuf),
                                         gdk_pixbuf_get_rowstride(pixbuf),
                                         width, height);
         if (!data) {
             g_object_unref(mask);
             return NS_ERROR_OUT_OF_MEMORY;
         }
 

--- widget/src/windows/nsWindow.cpp	4 Jan 2007 18:43:26 -0000	3.680
+++ widget/src/windows/nsWindow.cpp	15 Jan 2007 21:08:31 -0000
@@ -2777,35 +2777,44 @@ HBITMAP nsWindow::CreateOpaqueAlphaChann
   free(opaque);
   return hAlpha;
 }
 
 NS_IMETHODIMP nsWindow::SetCursor(imgIContainer* aCursor,
                                   PRUint32 aHotspotX, PRUint32 aHotspotY)
 {
   if (gCursorImgContainer == aCursor && gHCursor) {
     ::SetCursor(gHCursor);
     return NS_OK;
   }
 
-#ifdef MOZ_CAIRO_GFX
+  // Get the image data
   nsCOMPtr<gfxIImageFrame> frame;
   aCursor->GetFrameAt(0, getter_AddRefs(frame));
   if (!frame)
     return NS_ERROR_NOT_AVAILABLE;
 
   PRInt32 width, height;
-  PRUint32 bpr;
-  gfx_format format;
   frame->GetWidth(&width);
   frame->GetHeight(&height);
+
+  // Reject cursors greater than 64 pixels in some direction, to prevent
+  // spoofing.
+  // XXX ideally we should rescale. Also, we could modify the API to
+  // allow trusted content to set larger cursors.
+  if (width > 64 || height > 64)
+    return NS_ERROR_NOT_AVAILABLE;
+
+#ifdef MOZ_CAIRO_GFX
+  PRUint32 bpr;
+  gfx_format format;
   frame->GetImageBytesPerRow(&bpr);
   frame->GetFormat(&format);
 
   frame->LockImageData();
 
   PRUint32 dataLen;
   PRUint8 *data;
   nsresult rv = frame->GetImageData(&data, &dataLen);
   if (NS_FAILED(rv)) {
     frame->UnlockImageData();
     return rv;
   }
@@ -2859,45 +2868,37 @@ NS_IMETHODIMP nsWindow::SetCursor(imgICo
   ::SetCursor(cursor);
 
   NS_IF_RELEASE(gCursorImgContainer);
   gCursorImgContainer = aCursor;
   NS_ADDREF(gCursorImgContainer);
 
   if (gHCursor != NULL)
     ::DestroyIcon(gHCursor);
   gHCursor = cursor;
 
 #else
 
-  // Get the image data
-  nsCOMPtr<gfxIImageFrame> frame;
-  aCursor->GetFrameAt(0, getter_AddRefs(frame));
-  if (!frame)
-    return NS_ERROR_NOT_AVAILABLE;
-
-  PRInt32 width, height;
-  frame->GetWidth(&width);
-  frame->GetHeight(&height);
-
   gfx_format format;
   nsresult rv = frame->GetFormat(&format);
   if (NS_FAILED(rv))
     return rv;
 
   if (format != gfxIFormats::BGR_A1 && format != gfxIFormats::BGR_A8 &&
       format != gfxIFormats::BGR)
     return NS_ERROR_UNEXPECTED;
 
   // On Win2k with nVidia video drivers 71.84 at 32 bit color, cursors that 
   // have 8 bit alpha are truncated to 64x64.  Skip cursors larger than that.
+  // This is redundant with checks above, but we'll leave it in as a reminder
+  // in case we start accepting larger cursors again
   if (IsWin2k() && (format == gfxIFormats::BGR_A8) &&
       (width > 64 || height > 64))
     return NS_ERROR_FAILURE;
 
   PRUint32 bpr;
   rv = frame->GetImageBytesPerRow(&bpr);
   if (NS_FAILED(rv))
     return rv;
 
   frame->LockImageData();
   PRUint32 dataLen;
   PRUint8* data;
