--- content/base/src/nsXMLHttpRequest.cpp	17 Jun 2007 13:50:50 -0000	1.182
+++ content/base/src/nsXMLHttpRequest.cpp	29 Jun 2007 07:49:19 -0000
@@ -122,16 +122,51 @@
 static void AddLoadFlags(nsIRequest *request, nsLoadFlags newFlags)
 {
   nsLoadFlags flags;
   request->GetLoadFlags(&flags);
   flags |= newFlags;
   request->SetLoadFlags(flags);
 }
 
+// Request headers not allowed to be set by unprivileged scripts
+const char *kInvalidRequestHeaders[] = {
+  "host", "content-length", "transfer-encoding", "via", "upgrade", nsnull
+};
+
+// Response headers not allowed to be read from unprivileged scripts
+const char *kInvalidResponseHeaders[] = {
+  "set-cookie", nsnull
+};
+
+// This will check whether a header is in the list of forbidden headers. If the
+// privilege parameter is not nsnull and the caller has this privilege enabled
+// the check will be skipped.
+static PRBool IsHeaderAllowed(const nsACString& header, const char **invalidHeaders, char *privilege)
+{
+  PRBool privileged = PR_FALSE;
+  if (privilege) {
+    nsIScriptSecurityManager *secMan = nsContentUtils::GetSecurityManager();
+    if (secMan) {
+      secMan->IsCapabilityEnabled(privilege,
+                                  &privileged);
+    }
+  }
+
+  if (!privileged) {
+    for (size_t i = 0; invalidHeaders[i]; ++i) {
+      if (header.LowerCaseEqualsASCII(invalidHeaders[i])) {
+        return PR_FALSE;
+      }
+    }
+  }
+
+  return PR_TRUE;
+}
+
 // Helper proxy class to be used when expecting an
 // multipart/x-mixed-replace stream of XML documents.
 
 class nsMultipartProxyListener : public nsIStreamListener
 {
 public:
   nsMultipartProxyListener(nsIStreamListener *dest);
   virtual ~nsMultipartProxyListener();
@@ -785,18 +820,26 @@ NS_IMETHODIMP
 nsXMLHttpRequest::GetAllResponseHeaders(char **_retval)
 {
   NS_ENSURE_ARG_POINTER(_retval);
   *_retval = nsnull;
 
   nsCOMPtr<nsIHttpChannel> httpChannel = GetCurrentHttpChannel();
 
   if (httpChannel) {
-    nsHeaderVisitor *visitor = nsnull;
-    NS_NEWXPCOM(visitor, nsHeaderVisitor);
+    // Prevent retrieving of certain HTTP headers (see bug 380418), unless
+    // the executing script has UniversalBrowserRead permission.
+    PRBool privileged = PR_FALSE;
+    nsIScriptSecurityManager *secMan = nsContentUtils::GetSecurityManager();
+    if (secMan) {
+      secMan->IsCapabilityEnabled("UniversalBrowserRead",
+                                  &privileged);
+    }
+
+    nsHeaderVisitor *visitor = new nsHeaderVisitor(privileged ? nsnull : kInvalidResponseHeaders);
     if (!visitor)
       return NS_ERROR_OUT_OF_MEMORY;
     NS_ADDREF(visitor);
 
     nsresult rv = httpChannel->VisitResponseHeaders(visitor);
     if (NS_SUCCEEDED(rv))
       *_retval = ToNewCString(visitor->Headers());
 
@@ -810,16 +853,24 @@ nsXMLHttpRequest::GetAllResponseHeaders(
 /* ACString getResponseHeader (in AUTF8String header); */
 NS_IMETHODIMP
 nsXMLHttpRequest::GetResponseHeader(const nsACString& header,
                                     nsACString& _retval)
 {
   nsresult rv = NS_OK;
   _retval.Truncate();
 
+  // Prevent retrieving of certain HTTP headers (see bug 380418), unless
+  // the executing script has UniversalBrowserRead permission.
+  if (!IsHeaderAllowed(header, kInvalidResponseHeaders, "UniversalBrowserRead")) {
+    NS_WARNING("refusing to read response header");
+    _retval.SetIsVoid(PR_TRUE);
+    return NS_OK;
+  }
+
   nsCOMPtr<nsIHttpChannel> httpChannel = GetCurrentHttpChannel();
 
   if (httpChannel) {
     rv = httpChannel->GetResponseHeader(header, _retval);
   }
 
   if (rv == NS_ERROR_NOT_AVAILABLE) {
     // Means no header
@@ -1751,38 +1802,19 @@ NS_IMETHODIMP
 nsXMLHttpRequest::SetRequestHeader(const nsACString& header,
                                    const nsACString& value)
 {
   if (!mChannel)             // open() initializes mChannel, and open()
     return NS_ERROR_FAILURE; // must be called before first setRequestHeader()
 
   // Prevent modification to certain HTTP headers (see bug 302263), unless
   // the executing script has UniversalBrowserWrite permission.
-
-  nsIScriptSecurityManager *secMan = nsContentUtils::GetSecurityManager();
-  if (!secMan) {
-    return NS_ERROR_FAILURE;
-  }
-
-  PRBool privileged;
-  nsresult rv = secMan->IsCapabilityEnabled("UniversalBrowserWrite",
-                                            &privileged);
-  if (NS_FAILED(rv))
-    return NS_ERROR_FAILURE;
-
-  if (!privileged) {
-    const char *kInvalidHeaders[] = {
-      "host", "content-length", "transfer-encoding", "via", "upgrade"
-    };
-    for (size_t i = 0; i < NS_ARRAY_LENGTH(kInvalidHeaders); ++i) {
-      if (header.LowerCaseEqualsASCII(kInvalidHeaders[i])) {
-        NS_WARNING("refusing to set request header");
-        return NS_OK;
-      }
-    }
+  if (!IsHeaderAllowed(header, kInvalidRequestHeaders, "UniversalBrowserWrite")) {
+    NS_WARNING("refusing to set request header");
+    return NS_OK;
   }
 
   nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(mChannel));
 
   if (httpChannel) {
     // We need to set, not add to, the header.
     return httpChannel->SetRequestHeader(header, value, PR_FALSE);
   }
@@ -2135,16 +2167,19 @@ nsXMLHttpRequest::GetInterface(const nsI
 }
 
 
 NS_IMPL_ISUPPORTS1(nsXMLHttpRequest::nsHeaderVisitor, nsIHttpHeaderVisitor)
 
 NS_IMETHODIMP nsXMLHttpRequest::
 nsHeaderVisitor::VisitHeader(const nsACString &header, const nsACString &value)
 {
+    if (mInvalidHeaders && !IsHeaderAllowed(header, mInvalidHeaders, nsnull))
+      return NS_OK;
+
     mHeaders.Append(header);
     mHeaders.Append(": ");
     mHeaders.Append(value);
     mHeaders.Append('\n');
     return NS_OK;
 }
 
 // DOM event class to handle progress notifications

--- content/base/src/nsXMLHttpRequest.h	18 Feb 2007 14:38:01 -0000	1.61
+++ content/base/src/nsXMLHttpRequest.h	29 Jun 2007 07:49:19 -0000
@@ -178,21 +178,22 @@ protected:
 
   nsCOMPtr<nsIStreamListener> mXMLParserStreamListener;
 
   // used to implement getAllResponseHeaders()
   class nsHeaderVisitor : public nsIHttpHeaderVisitor {
   public:
     NS_DECL_ISUPPORTS
     NS_DECL_NSIHTTPHEADERVISITOR
-    nsHeaderVisitor() { }
+    nsHeaderVisitor(const char **invalidHeaders) : mInvalidHeaders(invalidHeaders) { }
     virtual ~nsHeaderVisitor() {}
     const nsACString &Headers() { return mHeaders; }
   private:
     nsCString mHeaders;
+    const char **mInvalidHeaders;
   };
 
   nsCString mResponseBody;
 
   nsCString mOverrideMimeType;
 
   /**
    * The notification callbacks the channel had when Send() was
