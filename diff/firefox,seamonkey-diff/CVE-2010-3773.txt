diff --git a/js/src/xpconnect/src/xpcwrappedjsclass.cpp b/js/src/xpconnect/src/xpcwrappedjsclass.cpp
--- a/js/src/xpconnect/src/xpcwrappedjsclass.cpp
+++ b/js/src/xpconnect/src/xpcwrappedjsclass.cpp
@@ -1319,16 +1319,41 @@ nsXPCWrappedJSClass::CallMethod(nsXPCWra
         goto pre_call_clean_up;
 
     scriptEval.StartEvaluating(xpcWrappedJSErrorReporter);
 
     xpcc->SetPendingResult(pending_result);
     xpcc->SetException(nsnull);
     ccx.GetThreadData()->SetException(nsnull);
 
+    if(XPCPerThreadData::IsMainThread(ccx))
+    {
+        ssm = XPCWrapper::GetSecurityManager();
+        if(ssm)
+        {
+            nsCOMPtr<nsIPrincipal> objPrincipal;
+            ssm->GetObjectPrincipal(ccx, obj, getter_AddRefs(objPrincipal));
+            if(objPrincipal)
+            {
+                JSStackFrame* fp = nsnull;
+                nsresult rv =
+                    ssm->PushContextPrincipal(ccx, JS_FrameIterator(ccx, &fp),
+                                              objPrincipal);
+                if(NS_FAILED(rv))
+                {
+                    JS_ReportOutOfMemory(ccx);
+                    retval = NS_ERROR_OUT_OF_MEMORY;
+                    goto pre_call_clean_up;
+                }
+
+                popPrincipal = JS_TRUE;
+            }
+        }
+    }
+
     // We use js_AllocStack, js_Invoke, and js_FreeStack so that the gcthings
     // we use as args will be rooted by the engine as we do conversions and
     // prepare to do the function call. This adds a fair amount of complexity,
     // but is a good optimization compared to calling JS_AddRoot for each item.
 
     js::LeaveTrace(cx);
 
     // setup stack
@@ -1655,41 +1680,16 @@ pre_call_clean_up:
 
     if(!readyToDoTheCall)
         goto done;
 
     // do the deed - note exceptions
 
     JS_ClearPendingException(cx);
 
-    if(XPCPerThreadData::IsMainThread(ccx))
-    {
-        ssm = XPCWrapper::GetSecurityManager();
-        if(ssm)
-        {
-            nsCOMPtr<nsIPrincipal> objPrincipal;
-            ssm->GetObjectPrincipal(ccx, obj, getter_AddRefs(objPrincipal));
-            if(objPrincipal)
-            {
-                JSStackFrame* fp = nsnull;
-                nsresult rv =
-                    ssm->PushContextPrincipal(ccx, JS_FrameIterator(ccx, &fp),
-                                              objPrincipal);
-                if(NS_FAILED(rv))
-                {
-                    JS_ReportOutOfMemory(ccx);
-                    retval = NS_ERROR_OUT_OF_MEMORY;
-                    goto done;
-                }
-
-                popPrincipal = JS_TRUE;
-            }
-        }
-    }
-
     if(XPT_MD_IS_GETTER(info->flags))
         success = JS_GetProperty(cx, obj, name, &result);
     else if(XPT_MD_IS_SETTER(info->flags))
         success = JS_SetProperty(cx, obj, name, sp-1);
     else
     {
         if(!JSVAL_IS_PRIMITIVE(fval))
         {
@@ -1716,19 +1716,16 @@ pre_call_clean_up:
                                            nsnull, getter_AddRefs(e), nsnull, nsnull);
             xpcc->SetException(e);
             if(sz)
                 JS_smprintf_free(sz);
             success = JS_FALSE;
         }
     }
 
-    if(popPrincipal)
-        ssm->PopContextPrincipal(ccx);
-
     if(!success)
     {
         PRBool forceReport;
         if(NS_FAILED(mInfo->IsFunction(&forceReport)))
             forceReport = PR_FALSE;
 
         // May also want to check if we're moving from content->chrome and force
         // a report in that case.
@@ -1934,16 +1931,19 @@ pre_call_clean_up:
         // set to whatever the JS code might have set as the result
         retval = pending_result;
     }
 
 done:
     if(sp)
         js_FreeStack(cx, mark);
 
+    if(popPrincipal)
+        ssm->PopContextPrincipal(ccx);
+
 #ifdef DEBUG_stats_jband
     endTime = PR_IntervalNow();
     printf("%s::%s %d ( c->js ) \n", GetInterfaceName(), info->GetName(), PR_IntervalToMilliseconds(endTime-startTime));
     totalTime += endTime-startTime;
 #endif
     return retval;
 }
 

