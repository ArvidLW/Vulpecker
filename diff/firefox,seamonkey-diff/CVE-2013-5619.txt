diff --git a/js/src/frontend/TokenStream.cpp b/js/src/frontend/TokenStream.cpp
--- a/js/src/frontend/TokenStream.cpp
+++ b/js/src/frontend/TokenStream.cpp
@@ -211,17 +211,17 @@ TokenStream::SourceCoords::lineIndexOf(u
     }
 
     // This is a binary search with deferred detection of equality, which was
     // marginally faster in this case than a standard binary search.
     // The -2 is because |lineStartOffsets_.length() - 1| is the sentinel, and we
     // want one before that.
     iMax = lineStartOffsets_.length() - 2;
     while (iMax > iMin) {
-        iMid = (iMin + iMax) / 2;
+        iMid = iMin + (iMax - iMin) / 2;
         if (offset >= lineStartOffsets_[iMid + 1])
             iMin = iMid + 1;    // offset is above lineStartOffsets_[iMid]
         else
             iMax = iMid;        // offset is below or within lineStartOffsets_[iMid]
     }
     JS_ASSERT(iMax == iMin);
     JS_ASSERT(lineStartOffsets_[iMin] <= offset && offset < lineStartOffsets_[iMin + 1]);
     lastLineIndex_ = iMin;
diff --git a/js/src/jit/BaselineJIT.cpp b/js/src/jit/BaselineJIT.cpp
--- a/js/src/jit/BaselineJIT.cpp
+++ b/js/src/jit/BaselineJIT.cpp
@@ -461,24 +461,24 @@ BaselineScript::pcMappingReader(size_t i
     return CompactBufferReader(dataStart, dataEnd);
 }
 
 ICEntry *
 BaselineScript::maybeICEntryFromReturnOffset(CodeOffsetLabel returnOffset)
 {
     size_t bottom = 0;
     size_t top = numICEntries();
-    size_t mid = (bottom + top) / 2;
+    size_t mid = bottom + (top - bottom) / 2;
     while (mid < top) {
         ICEntry &midEntry = icEntry(mid);
         if (midEntry.returnOffset().offset() < returnOffset.offset())
             bottom = mid + 1;
         else // if (midEntry.returnOffset().offset() >= returnOffset.offset())
             top = mid;
-        mid = (bottom + top) / 2;
+        mid = bottom + (top - bottom) / 2;
     }
     if (mid >= numICEntries())
         return NULL;
 
     if (icEntry(mid).returnOffset().offset() != returnOffset.offset())
         return NULL;
 
     return &icEntry(mid);
@@ -500,26 +500,26 @@ BaselineScript::returnAddressForIC(const
 
 ICEntry &
 BaselineScript::icEntryFromPCOffset(uint32_t pcOffset)
 {
     // Multiple IC entries can have the same PC offset, but this method only looks for
     // those which have isForOp() set.
     size_t bottom = 0;
     size_t top = numICEntries();
-    size_t mid = (bottom + top) / 2;
+    size_t mid = bottom + (top - bottom) / 2;
     while (mid < top) {
         ICEntry &midEntry = icEntry(mid);
         if (midEntry.pcOffset() < pcOffset)
             bottom = mid + 1;
         else if (midEntry.pcOffset() > pcOffset)
             top = mid;
         else
             break;
-        mid = (bottom + top) / 2;
+        mid = bottom + (top - bottom) / 2;
     }
     // Found an IC entry with a matching PC offset.  Search backward, and then
     // forward from this IC entry, looking for one with the same PC offset which
     // has isForOp() set.
     for (size_t i = mid; i < numICEntries() && icEntry(i).pcOffset() == pcOffset; i--) {
         if (icEntry(i).isForOp())
             return icEntry(i);
     }
diff --git a/js/src/jsinferinlines.h b/js/src/jsinferinlines.h
--- a/js/src/jsinferinlines.h
+++ b/js/src/jsinferinlines.h
@@ -715,25 +715,25 @@ TypeScript::BytecodeTypes(JSScript *scri
 
     // See if this pc is the same as the last one looked up.
     if (bytecodeMap[*hint] == offset)
         return script->types->typeArray()->toStackSet() + *hint;
 
     // Fall back to a binary search.
     size_t bottom = 0;
     size_t top = script->nTypeSets - 1;
-    size_t mid = (bottom + top) / 2;
+    size_t mid = bottom + (top - bottom) / 2;
     while (mid < top) {
         if (bytecodeMap[mid] < offset)
             bottom = mid + 1;
         else if (bytecodeMap[mid] > offset)
             top = mid;
         else
             break;
-        mid = (bottom + top) / 2;
+        mid = bottom + (top - bottom) / 2;
     }
 
     // We should have have zeroed in on either the exact offset, unless there
     // are more JOF_TYPESET opcodes than nTypeSets in the script (as can happen
     // if the script is very long).
     JS_ASSERT(bytecodeMap[mid] == offset || mid == top);
 
     *hint = mid;