diff --git a/layout/base/nsPresShell.cpp b/layout/base/nsPresShell.cpp
--- a/layout/base/nsPresShell.cpp
+++ b/layout/base/nsPresShell.cpp
@@ -5939,17 +5939,16 @@ PresShell::HandleEvent(nsIFrame        *
                 target->GetContentForEvent(aEvent, getter_AddRefs(targetContent));
                 while (targetContent && !targetContent->IsElement()) {
                   targetContent = targetContent->GetParent();
                 }
                 touch->SetTarget(targetContent);
                 gCaptureTouchList.Put(id, touch);
               }
             }
-
             if (target) {
               frame = target;
             }
           } else {
             // This touch is an old touch, we need to ensure that is not
             // marked as changed and set its target correctly
             touch->mChanged = false;
             int32_t id;
@@ -6012,16 +6011,56 @@ PresShell::HandleEvent(nsIFrame        *
         }
       }
 
       return NS_OK;
     }
 
     PresShell* shell =
         static_cast<PresShell*>(frame->PresContext()->PresShell());
+    switch (aEvent->message) {
+      case NS_TOUCH_MOVE:
+      case NS_TOUCH_CANCEL:
+      case NS_TOUCH_END: {
+        // Remove the changed touches
+        // need to make sure we only remove touches that are ending here
+        nsTouchEvent* touchEvent = static_cast<nsTouchEvent*>(aEvent);
+        nsTArray<nsCOMPtr<nsIDOMTouch> >  &touches = touchEvent->touches;
+        for (uint32_t i = 0; i < touches.Length(); ++i) {
+          nsIDOMTouch *touch = touches[i];
+          if (!touch) {
+            break;
+          }
+  
+          int32_t id;
+          touch->GetIdentifier(&id);
+          nsCOMPtr<nsIDOMTouch> oldTouch;
+          gCaptureTouchList.Get(id, getter_AddRefs(oldTouch));
+          if (!oldTouch) {
+            break;
+          }
+  
+          nsCOMPtr<nsPIDOMEventTarget> targetPtr;
+          oldTouch->GetTarget(getter_AddRefs(targetPtr));
+          nsCOMPtr<nsIContent> content = do_QueryInterface(targetPtr);
+          if (!content) {
+            break;
+          }
+
+          nsIFrame* contentFrame = content->GetPrimaryFrame();
+          if (!contentFrame) {
+            break;
+          }
+
+          shell = static_cast<PresShell*>(
+                      contentFrame->PresContext()->PresShell());
+        }
+        break;
+      }
+    }
 
     // Check if we have an active EventStateManager which isn't the
     // EventStateManager of the current PresContext.
     // If that is the case, and mouse is over some ancestor document,
     // forward event handling to the active document.
     // This way content can get mouse events even when
     // mouse is over the chrome or outside the window.
     //
@@ -6536,17 +6575,16 @@ PresShell::HandleEventInternal(nsEvent* 
 }
 
 void
 PresShell::DispatchTouchEvent(nsEvent *aEvent,
                               nsEventStatus* aStatus,
                               nsPresShellEventCB* aEventCB,
                               bool aTouchIsNew)
 {
-  nsresult rv = NS_OK;
   // calling preventDefault on touchstart or the first touchmove for a
   // point prevents mouse events
   bool canPrevent = aEvent->message == NS_TOUCH_START ||
               (aEvent->message == NS_TOUCH_MOVE && aTouchIsNew);
   bool preventDefault = false;
   nsEventStatus tmpStatus = nsEventStatus_eIgnore;
   nsTouchEvent* touchEvent = static_cast<nsTouchEvent*>(aEvent);
 
@@ -6559,42 +6597,49 @@ PresShell::DispatchTouchEvent(nsEvent *a
 
     nsCOMPtr<nsPIDOMEventTarget> targetPtr;
     touch->GetTarget(getter_AddRefs(targetPtr));
     nsCOMPtr<nsIContent> content = do_QueryInterface(targetPtr);
     if (!content) {
       continue;
     }
 
+    nsIDocument* doc = content->OwnerDoc();
     nsIContent* capturingContent = GetCapturingContent();
     if (capturingContent) {
-      if (capturingContent->OwnerDoc() != content->OwnerDoc()) {
+      if (capturingContent->OwnerDoc() != doc) {
         // Wrong document, don't dispatch anything.
         continue;
       }
       content = capturingContent;
     }
     // copy the event
     nsTouchEvent newEvent(NS_IS_TRUSTED_EVENT(touchEvent) ?
                             true : false,
                           touchEvent);
     newEvent.target = targetPtr;
 
     nsRefPtr<PresShell> contentPresShell;
-    if (content->OwnerDoc() == mDocument) {
-      contentPresShell = static_cast<PresShell*>
-          (content->OwnerDoc()->GetShell());
+    if (doc == mDocument) {
+      contentPresShell = static_cast<PresShell*>(doc->GetShell());
       if (contentPresShell) {
         //XXXsmaug huge hack. Pushing possibly capturing content,
         //         even though event target is something else.
         contentPresShell->PushCurrentEventInfo(
             content->GetPrimaryFrame(), content);
       }
     }
-    nsPresContext *context = nsContentUtils::GetContextForContent(content);
+
+    nsIPresShell *presShell = doc->GetShell();
+    if (!presShell) {
+      continue;
+    }
+
+    nsPresContext *context = presShell->GetPresContext();
+
     tmpStatus = nsEventStatus_eIgnore;
     nsEventDispatcher::Dispatch(targetPtr, context,
                                 &newEvent, nullptr, &tmpStatus, aEventCB);
     if (nsEventStatus_eConsumeNoDefault == tmpStatus) {
       preventDefault = true;
     }
 
     if (contentPresShell) {
diff --git a/layout/xul/base/src/nsSliderFrame.cpp b/layout/xul/base/src/nsSliderFrame.cpp
--- a/layout/xul/base/src/nsSliderFrame.cpp
+++ b/layout/xul/base/src/nsSliderFrame.cpp
@@ -525,17 +525,16 @@ nsSliderFrame::HandleEvent(nsPresContext
               (static_cast<nsMouseEvent*>(aEvent)->IsAlt() != GetScrollToClick())) ||
 #else
               (static_cast<nsMouseEvent*>(aEvent)->IsShift() != GetScrollToClick())) ||
 #endif
              (gMiddlePref && aEvent->message == NS_MOUSE_BUTTON_DOWN &&
               static_cast<nsMouseEvent*>(aEvent)->button ==
                 nsMouseEvent::eMiddleButton) ||
              (aEvent->message == NS_TOUCH_START && GetScrollToClick())) {
-
     nsPoint eventPoint;
     if (!GetEventPoint(aEvent, eventPoint)) {
       return NS_OK;
     }
     nscoord pos = isHorizontal ? eventPoint.x : eventPoint.y;
 
     // adjust so that the middle of the thumb is placed under the click
     nsIFrame* thumbFrame = mFrames.FirstChild();
@@ -845,17 +844,16 @@ nsSliderMediator::HandleEvent(nsIDOMEven
 }
 
 nsresult
 nsSliderFrame::StartDrag(nsIDOMEvent* aEvent)
 {
 #ifdef DEBUG_SLIDER
   printf("Begin dragging\n");
 #endif
-
   if (mContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::disabled,
                             nsGkAtoms::_true, eCaseMatters))
     return NS_OK;
 
   bool isHorizontal = IsHorizontal();
   bool scrollToClick = false;
 
   nsCOMPtr<nsIDOMMouseEvent> mouseEvent(do_QueryInterface(aEvent));
@@ -983,17 +981,16 @@ nsSliderFrame::RemoveListener()
 }
 
 NS_IMETHODIMP
 nsSliderFrame::HandlePress(nsPresContext* aPresContext,
                            nsGUIEvent*     aEvent,
                            nsEventStatus*  aEventStatus)
 {
   if (aEvent->message == NS_TOUCH_START && GetScrollToClick()) {
-    printf("Bailing for touch\n");
     return NS_OK;
   }
 
   if (aEvent->message == NS_MOUSE_BUTTON_DOWN) {
 #ifdef XP_MACOSX
     // On Mac the option key inverts the scroll-to-here preference.
     if (((nsMouseEvent *)aEvent)->IsAlt() != GetScrollToClick()) {
 #else