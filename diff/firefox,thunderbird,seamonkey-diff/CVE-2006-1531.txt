--- layout/base/nsCSSFrameConstructor.cpp	11 Feb 2006 11:26:57 -0000	1.1194
+++ layout/base/nsCSSFrameConstructor.cpp	12 Feb 2006 21:35:09 -0000
@@ -9325,23 +9325,29 @@ PRBool NotifyListBoxBody(nsPresContext* 
     nsCOMPtr<nsIDOMXULElement> xulElement = do_QueryInterface(aContainer);
     nsCOMPtr<nsIBoxObject> boxObject;
     xulElement->GetBoxObject(getter_AddRefs(boxObject));
     nsCOMPtr<nsPIListBoxObject> listBoxObject = do_QueryInterface(boxObject);
     if (listBoxObject) {
       nsIListBoxObject* listboxBody = listBoxObject->GetListBoxBody();
       if (listboxBody) {
         nsListBoxBodyFrame *listBoxBodyFrame = NS_STATIC_CAST(nsListBoxBodyFrame*, listboxBody);
-        if (aOperation == CONTENT_REMOVED)
-          listBoxBodyFrame->OnContentRemoved(aPresContext, aChildFrame, aIndexInContainer);
-        else
+        if (aOperation == CONTENT_REMOVED) {
+          // Except if we have an aChildFrame and its parent is not the right
+          // thing, then we don't do this.  Pseudo frames are so much fun....
+          if (!aChildFrame || aChildFrame->GetParent() == listBoxBodyFrame) {
+            listBoxBodyFrame->OnContentRemoved(aPresContext, aChildFrame,
+                                               aIndexInContainer);
+            return PR_TRUE;
+          }
+        } else {
           listBoxBodyFrame->OnContentInserted(aPresContext, aChild);
-        //NS_RELEASE(listBoxBodyFrame); frames aren't refcounted
+          return PR_TRUE;
+        }
       }
-      return PR_TRUE;
     }
   }
 
   nsCOMPtr<nsIAtom> tag;
   PRInt32 namespaceID;
   aDocument->BindingManager()->ResolveTag(aContainer, &namespaceID,
                                           getter_AddRefs(tag));
 
--- layout/xul/base/src/nsListBoxBodyFrame.cpp	30 Jan 2006 21:28:52 -0000	1.58
+++ layout/xul/base/src/nsListBoxBodyFrame.cpp	12 Feb 2006 21:35:10 -0000
@@ -1313,16 +1313,19 @@ nsListBoxBodyFrame::OnContentInserted(ns
 }
 
 // 
 // Called by nsCSSFrameConstructor when listitem content is removed.
 //
 void
 nsListBoxBodyFrame::OnContentRemoved(nsPresContext* aPresContext, nsIFrame* aChildFrame, PRInt32 aIndex)
 {
+  NS_ASSERTION(!aChildFrame || aChildFrame->GetParent() == this,
+               "Removing frame that's not our child... Not good");
+  
   if (mRowCount >= 0)
     --mRowCount;
 
   if (!aChildFrame) {
     // The row we are removing is out of view, so we need to try to
     // determine the index of its next sibling.
     nsIContent *oldNextSiblingContent =
       mContent->GetBindingParent()->GetChildAt(aIndex);
@@ -1431,17 +1434,22 @@ nsListBoxBodyFrame::GetListItemNextSibli
 void
 nsListBoxBodyFrame::RemoveChildFrame(nsBoxLayoutState &aState,
                                      nsIFrame         *aFrame)
 {
   nsPresContext* presContext = GetPresContext();
   nsCSSFrameConstructor* fc = presContext->PresShell()->FrameConstructor();
   fc->RemoveMappingsForFrameSubtree(aFrame);
 
-  mFrames.RemoveFrame(aFrame);
+#ifdef DEBUG
+  PRBool removed =
+#endif
+    mFrames.RemoveFrame(aFrame);
+  NS_ASSERTION(removed,
+               "Going to destroy a frame we didn't remove.  Prepare to crash");
   if (mLayoutManager)
     mLayoutManager->ChildrenRemoved(this, aState, aFrame);
   aFrame->Destroy(presContext);
 }
 
 // Creation Routines ///////////////////////////////////////////////////////////////////////
 
 nsIFrame*
