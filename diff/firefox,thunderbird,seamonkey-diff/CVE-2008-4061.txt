diff --git a/layout/mathml/base/src/nsMathMLmtableFrame.cpp b/layout/mathml/base/src/nsMathMLmtableFrame.cpp
--- a/layout/mathml/base/src/nsMathMLmtableFrame.cpp
+++ b/layout/mathml/base/src/nsMathMLmtableFrame.cpp
@@ -756,30 +756,34 @@ NS_NewMathMLmtdFrame(nsIPresShell* aPres
 {
   return new (aPresShell) nsMathMLmtdFrame(aContext);
 }
 
 nsMathMLmtdFrame::~nsMathMLmtdFrame()
 {
 }
 
+#define MAX_ROWSPAN 8190 // celldata.h can not handle more
+#define MAX_COLSPAN 1000 // limit as IE and opera do
+
 PRInt32
 nsMathMLmtdFrame::GetRowSpan()
 {
   PRInt32 rowspan = 1;
 
   // Don't look at the content's rowspan if we're not an mtd or a pseudo cell.
   if ((mContent->Tag() == nsGkAtoms::mtd_) && !GetStyleContext()->GetPseudoType()) {
     nsAutoString value;
     mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::rowspan, value);
     if (!value.IsEmpty()) {
       PRInt32 error;
       rowspan = value.ToInteger(&error);
       if (error || rowspan < 0)
         rowspan = 1;
+      rowspan = PR_MIN(rowspan, MAX_ROWSPAN);
     }
   }
   return rowspan;
 }
 
 PRInt32
 nsMathMLmtdFrame::GetColSpan()
 {
@@ -787,17 +791,17 @@ nsMathMLmtdFrame::GetColSpan()
 
   // Don't look at the content's colspan if we're not an mtd or a pseudo cell.
   if ((mContent->Tag() == nsGkAtoms::mtd_) && !GetStyleContext()->GetPseudoType()) {
     nsAutoString value;
     mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::columnspan_, value);
     if (!value.IsEmpty()) {
       PRInt32 error;
       colspan = value.ToInteger(&error);
-      if (error || colspan < 0)
+      if (error || colspan < 0 || colspan > MAX_COLSPAN)
         colspan = 1;
     }
   }
   return colspan;
 }
 
 NS_IMETHODIMP
 nsMathMLmtdFrame::AttributeChanged(PRInt32  aNameSpaceID,
diff --git a/xpcom/glue/nsTArray.cpp b/xpcom/glue/nsTArray.cpp
--- a/xpcom/glue/nsTArray.cpp
+++ b/xpcom/glue/nsTArray.cpp
@@ -60,17 +60,17 @@ nsTArray_base::EnsureCapacity(size_type 
   // This should be the most common case so test this first
   if (capacity <= mHdr->mCapacity)
     return PR_TRUE;
 
   // If the requested memory allocation exceeds size_type(-1)/2, then our
   // doubling algorithm may not be able to allocate it.  Additionally we
   // couldn't fit in the Header::mCapacity member. Just bail out in cases
   // like that.  We don't want to be allocating 2 GB+ arrays anyway.
-  if (capacity * elemSize > size_type(-1)/2) {
+  if ((PRUint64)capacity * elemSize > size_type(-1)/2) {
     NS_ERROR("Attempting to allocate excessively large array");
     return PR_FALSE;
   }
 
   if (mHdr == &sEmptyHdr) {
     // NS_Alloc new data
     Header *header = static_cast<Header*>
                                 (NS_Alloc(sizeof(Header) + capacity * elemSize));
