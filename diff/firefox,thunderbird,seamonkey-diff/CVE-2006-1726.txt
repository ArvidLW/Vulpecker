--- jsfun.c	22 Jan 2006 21:08:05 -0000	3.134
+++ jsfun.c	25 Jan 2006 02:51:09 -0000
@@ -1758,21 +1758,21 @@ Function(JSContext *cx, JSObject *obj, u
         filename = caller->script->filename;
         lineno = js_PCToLineNumber(cx, caller->script, caller->pc);
         principals = JS_EvalFramePrincipals(cx, fp, caller);
     } else {
         filename = NULL;
         lineno = 0;
         principals = NULL;
     }
 
     /* Belt-and-braces: check that the caller has access to parent. */
-    if (!js_CheckPrincipalsAccess(cx, parent, principals, "Function"))
+    if (!js_CheckPrincipalsAccess(cx, parent, principals, js_Function_str))
         return JS_FALSE;
 
     n = argc ? argc - 1 : 0;
     if (n > 0) {
         /*
          * Collect the function-argument arguments into one string, separated
          * by commas, then make a tokenstream from that string, and scan it to
          * get the arguments.  We need to throw the full scanner at the
          * problem, because the argument string can legitimately contain
          * comments and linefeeds.  XXX It might be better to concatenate
@@ -2118,36 +2118,49 @@ js_ValueToFunction(JSContext *cx, jsval 
         return NULL;
     }
     return (JSFunction *) JS_GetPrivate(cx, obj);
 }
 
 JSObject *
 js_ValueToFunctionObject(JSContext *cx, jsval *vp, uintN flags)
 {
     JSFunction *fun;
     JSObject *funobj;
-    JSStackFrame *caller;
+    JSStackFrame *fp, *caller;
+    JSPrincipals *principals;
 
     if (JSVAL_IS_FUNCTION(cx, *vp))
         return JSVAL_TO_OBJECT(*vp);
 
     fun = js_ValueToFunction(cx, vp, flags);
     if (!fun)
         return NULL;
     funobj = fun->object;
     *vp = OBJECT_TO_JSVAL(funobj);
 
-    caller = JS_GetScriptedCaller(cx, cx->fp);
-    if (caller &&
-        !js_CheckPrincipalsAccess(cx, funobj,
-                                  caller->script->principals,
-                                  JS_GetFunctionName(fun))) {
+    fp = cx->fp;
+    caller = JS_GetScriptedCaller(cx, fp);
+    if (caller) {
+        principals = caller->script->principals;
+    } else {
+        /* No scripted caller, don't allow access. */
+        principals = NULL;
+    }
+
+    /*
+     * FIXME: Reparameterize so we don't call js_AtomToPrintableString unless
+     *        there is an error.
+     */
+    if (!js_CheckPrincipalsAccess(cx, funobj, principals,
+                                  fun->atom
+                                  ? js_AtomToPrintableString(cx, fun->atom)
+                                  : js_anonymous_str)) {
         return NULL;
     }
     return funobj;
 }
 
 JSObject *
 js_ValueToCallableObject(JSContext *cx, jsval *vp, uintN flags)
 {
     JSObject *callable;
 
