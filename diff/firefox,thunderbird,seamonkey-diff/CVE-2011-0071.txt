diff --git a/netwerk/protocol/res/nsResProtocolHandler.cpp b/netwerk/protocol/res/nsResProtocolHandler.cpp
--- a/netwerk/protocol/res/nsResProtocolHandler.cpp
+++ b/netwerk/protocol/res/nsResProtocolHandler.cpp
@@ -462,38 +462,37 @@ nsResProtocolHandler::HasSubstitution(co
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsResProtocolHandler::ResolveURI(nsIURI *uri, nsACString &result)
 {
     nsresult rv;
 
-    nsCOMPtr<nsIURL> url(do_QueryInterface(uri));
-    if (!url)
-        return NS_NOINTERFACE;
-
     nsCAutoString host;
     nsCAutoString path;
 
     rv = uri->GetAsciiHost(host);
     if (NS_FAILED(rv)) return rv;
 
     rv = uri->GetPath(path);
     if (NS_FAILED(rv)) return rv;
 
-    nsCAutoString filepath;
-    url->GetFilePath(filepath);
+    // Unescape the path so we can perform some checks on it.
+    nsCAutoString unescapedPath(path);
+    NS_UnescapeURL(unescapedPath);
 
     // Don't misinterpret the filepath as an absolute URI.
-    if (filepath.FindChar(':') != -1)
+    if (unescapedPath.FindChar(':') != -1)
         return NS_ERROR_MALFORMED_URI;
 
-    NS_UnescapeURL(filepath);
-    if (filepath.FindChar('\\') != -1)
+    // Prevent '\' so path coalescence doesn't get circumvented.
+    // ('\' isn't normalized to '/' before coalescence occurs
+    // in nsResProtocolHandler::NewURI.) See bug 367428 and bug 624764.
+    if (unescapedPath.FindChar('\\') != -1)
         return NS_ERROR_MALFORMED_URI;
 
     const char *p = path.get() + 1; // path always starts with a slash
     NS_ASSERTION(*(p-1) == '/', "Path did not begin with a slash!");
 
     if (*p == '/')
         return NS_ERROR_MALFORMED_URI;
 