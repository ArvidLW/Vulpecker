diff --git a/layout/generic/nsTextFrameThebes.cpp b/layout/generic/nsTextFrameThebes.cpp
--- a/layout/generic/nsTextFrameThebes.cpp
+++ b/layout/generic/nsTextFrameThebes.cpp
@@ -2336,20 +2336,20 @@ PropertyProvider::ComputeJustifiableChar
     }
   }
   return justifiableChars;
 }
 
 /**
  * Finds the offset of the first character of the cluster containing aPos
  */
-static void FindClusterStart(gfxTextRun* aTextRun,
+static void FindClusterStart(gfxTextRun* aTextRun, PRInt32 aOriginalStart,
                              gfxSkipCharsIterator* aPos)
 {
-  while (aPos->GetOriginalOffset() > 0) {
+  while (aPos->GetOriginalOffset() > aOriginalStart) {
     if (aPos->IsOriginalCharSkipped() ||
         aTextRun->IsClusterStart(aPos->GetSkippedOffset())) {
       break;
     }
     aPos->AdvanceOriginal(-1);
   }
 }
 
@@ -2460,17 +2460,17 @@ PropertyProvider::GetSpacingInternal(PRU
       run(start, nsSkipCharsRunIterator::LENGTH_UNSKIPPED_ONLY, aLength);
     while (run.NextRun()) {
       PRInt32 i;
       gfxSkipCharsIterator iter = run.GetPos();
       for (i = 0; i < run.GetRunLength(); ++i) {
         PRInt32 originalOffset = run.GetOriginalOffset() + i;
         if (IsJustifiableCharacter(mFrag, originalOffset, isCJK)) {
           iter.SetOriginalOffset(originalOffset);
-          FindClusterStart(mTextRun, &iter);
+          FindClusterStart(mTextRun, run.GetOriginalOffset(), &iter);
           PRUint32 clusterFirstChar = iter.GetSkippedOffset();
           FindClusterEnd(mTextRun, run.GetOriginalOffset() + run.GetRunLength(), &iter);
           PRUint32 clusterLastChar = iter.GetSkippedOffset();
           // Only apply justification to characters before justificationEnd
           if (clusterFirstChar >= justificationStart.GetSkippedOffset() &&
               clusterLastChar < justificationEnd.GetSkippedOffset()) {
             aSpacing[clusterFirstChar - aStart].mBefore += halfJustificationSpace;
             aSpacing[clusterLastChar - aStart].mAfter += halfJustificationSpace;
@@ -5057,25 +5057,25 @@ nsTextFrame::SetSelectedRange(PRUint32 a
     IsSelectable(&selectable, nsnull);
     if (!selectable)
       return;
   }
 
   PRBool anySelected = PR_FALSE;
 
   nsTextFrame* f = this;
-  while (f && f->GetContentEnd() <= aStart) {
+  while (f && f->GetContentEnd() <= PRInt32(aStart)) {
     if (f->GetStateBits() & NS_FRAME_SELECTED_CONTENT) {
       anySelected = PR_TRUE;
     }
     f = static_cast<nsTextFrame*>(f->GetNextContinuation());
   }
 
   nsPresContext* presContext = PresContext();
-  while (f && f->GetContentOffset() < aEnd) {
+  while (f && f->GetContentOffset() < PRInt32(aEnd)) {
     if (aSelected) {
       f->AddStateBits(NS_FRAME_SELECTED_CONTENT);
       anySelected = PR_TRUE;
     } else { // we need to see if any other selection is available.
       SelectionDetails *details = f->GetSelectionDetails();
       if (details) {
         anySelected = PR_TRUE;
         DestroySelectionDetails(details);
@@ -5160,17 +5160,17 @@ nsTextFrame::GetPointFromOffset(PRInt32 
   inOffset = NS_MIN(inOffset, trimmedEnd);
 
   iter.SetOriginalOffset(inOffset);
 
   if (inOffset < trimmedEnd &&
       !iter.IsOriginalCharSkipped() &&
       !mTextRun->IsClusterStart(iter.GetSkippedOffset())) {
     NS_WARNING("GetPointFromOffset called for non-cluster boundary");
-    FindClusterStart(mTextRun, &iter);
+    FindClusterStart(mTextRun, trimmedOffset, &iter);
   }
 
   gfxFloat advanceWidth =
     mTextRun->GetAdvanceWidth(properties.GetStart().GetSkippedOffset(),
                               GetSkippedDistance(properties.GetStart(), iter),
                               &properties);
   nscoord width = NSToCoordCeilClamped(advanceWidth);
 
