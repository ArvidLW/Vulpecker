diff --git a/layout/base/nsPresContext.cpp b/layout/base/nsPresContext.cpp
--- a/layout/base/nsPresContext.cpp
+++ b/layout/base/nsPresContext.cpp
@@ -1701,17 +1701,17 @@ InsertFontFaceRule(nsCSSFontFaceRule *aR
 
   // set up src array
   nsTArray<gfxFontFaceSrc> srcArray;
 
   aRule->GetDesc(eCSSFontDesc_Src, val);
   unit = val.GetUnit();
   if (unit == eCSSUnit_Array) {
     nsCSSValue::Array *srcArr = val.GetArrayValue();
-    PRUint32 i, numSrc = srcArr->Count();
+    size_t i, numSrc = srcArr->Count();
     
     for (i = 0; i < numSrc; i++) {
       val = srcArr->Item(i);
       unit = val.GetUnit();
       gfxFontFaceSrc *face = srcArray.AppendElements(1);
       if (!face)
         return;
             
diff --git a/layout/style/nsCSSValue.h b/layout/style/nsCSSValue.h
--- a/layout/style/nsCSSValue.h
+++ b/layout/style/nsCSSValue.h
@@ -546,89 +546,89 @@ private:
   // not to be implemented
   nsCSSValueGradient(const nsCSSValueGradient& aOther);
   nsCSSValueGradient& operator=(const nsCSSValueGradient& aOther);
 };
 
 struct nsCSSValue::Array {
 
   // return |Array| with reference count of zero
-  static Array* Create(PRUint16 aItemCount) {
+  static Array* Create(size_t aItemCount) {
     return new (aItemCount) Array(aItemCount);
   }
 
-  nsCSSValue& operator[](PRUint16 aIndex) {
+  nsCSSValue& operator[](size_t aIndex) {
     NS_ASSERTION(aIndex < mCount, "out of range");
     return mArray[aIndex];
   }
 
-  const nsCSSValue& operator[](PRUint16 aIndex) const {
+  const nsCSSValue& operator[](size_t aIndex) const {
     NS_ASSERTION(aIndex < mCount, "out of range");
     return mArray[aIndex];
   }
 
-  nsCSSValue& Item(PRUint16 aIndex) { return (*this)[aIndex]; }
-  const nsCSSValue& Item(PRUint16 aIndex) const { return (*this)[aIndex]; }
+  nsCSSValue& Item(size_t aIndex) { return (*this)[aIndex]; }
+  const nsCSSValue& Item(size_t aIndex) const { return (*this)[aIndex]; }
 
-  PRUint16 Count() const { return mCount; }
+  size_t Count() const { return mCount; }
 
   PRBool operator==(const Array& aOther) const
   {
     if (mCount != aOther.mCount)
       return PR_FALSE;
-    for (PRUint16 i = 0; i < mCount; ++i)
+    for (size_t i = 0; i < mCount; ++i)
       if ((*this)[i] != aOther[i])
         return PR_FALSE;
     return PR_TRUE;
   }
 
   void AddRef() {
-    if (mRefCnt == PR_UINT16_MAX) {
+    if (mRefCnt == size_t(-1)) { // really want SIZE_MAX
       NS_WARNING("refcount overflow, leaking nsCSSValue::Array");
       return;
     }
     ++mRefCnt;
     NS_LOG_ADDREF(this, mRefCnt, "nsCSSValue::Array", sizeof(*this));
   }
   void Release() {
-    if (mRefCnt == PR_UINT16_MAX) {
+    if (mRefCnt == size_t(-1)) { // really want SIZE_MAX
       NS_WARNING("refcount overflow, leaking nsCSSValue::Array");
       return;
     }
     --mRefCnt;
     NS_LOG_RELEASE(this, mRefCnt, "nsCSSValue::Array");
     if (mRefCnt == 0)
       delete this;
   }
 
 private:
 
-  PRUint16 mRefCnt;
-  const PRUint16 mCount;
+  size_t mRefCnt;
+  const size_t mCount;
   // This must be the last sub-object, since we extend this array to
   // be of size mCount; it needs to be a sub-object so it gets proper
   // alignment.
   nsCSSValue mArray[1];
 
-  void* operator new(size_t aSelfSize, PRUint16 aItemCount) CPP_THROW_NEW {
+  void* operator new(size_t aSelfSize, size_t aItemCount) CPP_THROW_NEW {
     NS_ABORT_IF_FALSE(aItemCount > 0, "cannot have a 0 item count");
     return ::operator new(aSelfSize + sizeof(nsCSSValue) * (aItemCount - 1));
   }
 
   void operator delete(void* aPtr) { ::operator delete(aPtr); }
 
   nsCSSValue* First() { return mArray; }
 
   const nsCSSValue* First() const { return mArray; }
 
 #define CSSVALUE_LIST_FOR_EXTRA_VALUES(var)                                   \
   for (nsCSSValue *var = First() + 1, *var##_end = First() + mCount;          \
        var != var##_end; ++var)
 
-  Array(PRUint16 aItemCount)
+  Array(size_t aItemCount)
     : mRefCnt(0)
     , mCount(aItemCount)
   {
     MOZ_COUNT_CTOR(nsCSSValue::Array);
     CSSVALUE_LIST_FOR_EXTRA_VALUES(val) {
       new (val) nsCSSValue();
     }
   }
