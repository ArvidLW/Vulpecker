diff --git a/rdf/base/src/nsRDFXMLDataSource.cpp b/rdf/base/src/nsRDFXMLDataSource.cpp
--- a/rdf/base/src/nsRDFXMLDataSource.cpp
+++ b/rdf/base/src/nsRDFXMLDataSource.cpp
@@ -118,16 +118,19 @@
 #include "prio.h"
 #include "prthread.h"
 #include "rdf.h"
 #include "rdfutil.h"
 #include "prlog.h"
 #include "nsNameSpaceMap.h"
 #include "nsCRT.h"
 #include "nsCycleCollectionParticipant.h"
+#include "nsIScriptSecurityManager.h"
+#include "nsIChannelEventSink.h"
+#include "nsNetUtil.h"
 
 #include "rdfIDataSource.h"
 
 //----------------------------------------------------------------------
 
 static NS_DEFINE_CID(kRDFInMemoryDataSourceCID, NS_RDFINMEMORYDATASOURCE_CID);
 static NS_DEFINE_CID(kRDFServiceCID,            NS_RDFSERVICE_CID);
 
@@ -140,17 +143,19 @@ static PRLogModuleInfo* gLog;
 // RDFXMLDataSourceImpl
 //
 
 class RDFXMLDataSourceImpl : public nsIRDFDataSource,
                              public nsIRDFRemoteDataSource,
                              public nsIRDFXMLSink,
                              public nsIRDFXMLSource,
                              public nsIStreamListener,
-                             public rdfIDataSource
+                             public rdfIDataSource,
+                             public nsIInterfaceRequestor,
+                             public nsIChannelEventSink
 {
 protected:
     enum LoadState {
         eLoadState_Unloaded,
         eLoadState_Pending,
         eLoadState_Loading,
         eLoadState_Loaded
     };
@@ -313,16 +318,22 @@ public:
     NS_DECL_NSIRDFXMLSOURCE
 
     // nsIRequestObserver
     NS_DECL_NSIREQUESTOBSERVER
 
     // nsIStreamListener
     NS_DECL_NSISTREAMLISTENER
 
+    // nsIInterfaceRequestor
+    NS_DECL_NSIINTERFACEREQUESTOR
+
+    // nsIChannelEventSink
+    NS_DECL_NSICHANNELEVENTSINK
+
     // rdfIDataSource
     NS_IMETHOD VisitAllSubjects(rdfITripleVisitor *aVisitor) {
         nsresult rv;
         nsCOMPtr<rdfIDataSource> rdfds = do_QueryInterface(mInner, &rv);
         if (NS_FAILED(rv)) return rv;
         return rdfds->VisitAllSubjects(aVisitor);
     } 
 
@@ -476,19 +487,27 @@ NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(RDFXMLDataSourceImpl)
     NS_INTERFACE_MAP_ENTRY(nsIRDFDataSource)
     NS_INTERFACE_MAP_ENTRY(nsIRDFRemoteDataSource)
     NS_INTERFACE_MAP_ENTRY(nsIRDFXMLSink)
     NS_INTERFACE_MAP_ENTRY(nsIRDFXMLSource)
     NS_INTERFACE_MAP_ENTRY(nsIRequestObserver)
     NS_INTERFACE_MAP_ENTRY(nsIStreamListener)
     NS_INTERFACE_MAP_ENTRY(rdfIDataSource)
+    NS_INTERFACE_MAP_ENTRY(nsIInterfaceRequestor)
+    NS_INTERFACE_MAP_ENTRY(nsIChannelEventSink)
     NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIRDFDataSource)
 NS_INTERFACE_MAP_END
 
+// nsIInterfaceRequestor
+NS_IMETHODIMP
+RDFXMLDataSourceImpl::GetInterface(const nsIID& aIID, void** aSink)
+{
+  return QueryInterface(aIID, aSink);
+}
 
 nsresult
 RDFXMLDataSourceImpl::BlockingParse(nsIURI* aURL, nsIStreamListener* aConsumer)
 {
     nsresult rv;
 
     // XXX I really hate the way that we're spoon-feeding this stuff
     // to the parser: it seems like this is something that netlib
@@ -872,16 +891,49 @@ RDFXMLDataSourceImpl::SetReadOnly(PRBool
     if (mIsWritable && aIsReadOnly)
         mIsWritable = PR_FALSE;
 
     return NS_OK;
 }
 
 #include "nsITimelineService.h"
 
+// nsIChannelEventSink
+
+// This code is copied from nsSameOriginChecker::OnChannelRedirect. See
+// bug 475940 on providing this code in a shared location.
+NS_IMETHODIMP
+RDFXMLDataSourceImpl::OnChannelRedirect(nsIChannel *aOldChannel,
+                                        nsIChannel *aNewChannel,
+                                        PRUint32 aFlags)
+{
+  NS_PRECONDITION(aNewChannel, "Redirecting to null channel?");
+
+  nsresult rv;
+  nsCOMPtr<nsIScriptSecurityManager> secMan =
+      do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  nsCOMPtr<nsIPrincipal> oldPrincipal;
+  secMan->GetChannelPrincipal(aOldChannel, getter_AddRefs(oldPrincipal));
+
+  nsCOMPtr<nsIURI> newURI;
+  aNewChannel->GetURI(getter_AddRefs(newURI));
+  nsCOMPtr<nsIURI> newOriginalURI;
+  aNewChannel->GetOriginalURI(getter_AddRefs(newOriginalURI));
+
+  NS_ENSURE_STATE(oldPrincipal && newURI && newOriginalURI);
+
+  rv = oldPrincipal->CheckMayLoad(newURI, PR_FALSE);
+  if (NS_SUCCEEDED(rv) && newOriginalURI != newURI) {
+    rv = oldPrincipal->CheckMayLoad(newOriginalURI, PR_FALSE);
+  }
+  return rv;
+}
+
 NS_IMETHODIMP
 RDFXMLDataSourceImpl::Refresh(PRBool aBlocking)
 {
 #ifdef PR_LOGGING
     nsCAutoString spec;
     if (mURL) {
         mURL->GetSpec(spec);
     }
@@ -920,17 +972,17 @@ RDFXMLDataSourceImpl::Refresh(PRBool aBl
         NS_TIMELINE_MARK_TIMER("rdf blocking parse");
 
         mListener = nsnull; // release the parser
 
         if (NS_FAILED(rv)) return rv;
     }
     else {
         // Null LoadGroup ?
-        rv = NS_OpenURI(this, nsnull, mURL, nsnull);
+        rv = NS_OpenURI(this, nsnull, mURL, nsnull, nsnull, this);
         if (NS_FAILED(rv)) return rv;
 
         // So we don't try to issue two asynchronous loads at once.
         mLoadState = eLoadState_Pending;
     }
 
     return NS_OK;
 }
