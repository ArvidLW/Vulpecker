diff --git a/content/html/document/src/nsHTMLFragmentContentSink.cpp b/content/html/document/src/nsHTMLFragmentContentSink.cpp
--- a/content/html/document/src/nsHTMLFragmentContentSink.cpp
+++ b/content/html/document/src/nsHTMLFragmentContentSink.cpp
@@ -61,16 +61,26 @@
 #include "nsEscape.h"
 #include "nsNodeInfoManager.h"
 #include "nsContentCreatorFunctions.h"
 #include "nsNetUtil.h"
 #include "nsIScriptSecurityManager.h"
 #include "nsContentSink.h"
 #include "nsTHashtable.h"
 #include "nsCycleCollectionParticipant.h"
+#include "nsCSSParser.h"
+#include "nsCSSProperty.h"
+#include "nsCSSDeclaration.h"
+#include "nsICSSStyleRule.h"
+#include "nsUnicharInputStream.h"
+#include "nsCSSStyleSheet.h"
+#include "nsICSSRuleList.h"
+#include "nsCSSDeclaration.h"
+#include "nsCSSProperty.h"
+#include "nsIDOMCSSRule.h"
 
 //
 // XXX THIS IS TEMPORARY CODE
 // There's a considerable amount of copied code from the
 // regular nsHTMLContentSink. All of it will be factored
 // at some pointe really soon!
 //
 
@@ -793,30 +803,34 @@ public:
   virtual void AllowStyles();
 
 protected:
   nsresult NameFromType(const nsHTMLTag aTag,
                         nsIAtom **aResult);
 
   nsresult NameFromNode(const nsIParserNode& aNode,
                         nsIAtom **aResult);
+
+  void SanitizeStyleRule(nsICSSStyleRule *aRule, nsAutoString &aRuleText);
   
-  PRBool mSkip; // used when we descend into <style> or <script>
-  PRBool mProcessStyle; // used when style is explicitly white-listed
+  PRPackedBool mSkip; // used when we descend into <style> or <script>
+  PRPackedBool mProcessStyle; // used when style is explicitly white-listed
+  PRPackedBool mInStyle; // whether we're inside a style element
 
   // Use nsTHashTable as a hash set for our whitelists
   static nsTHashtable<nsISupportsHashKey>* sAllowedTags;
   static nsTHashtable<nsISupportsHashKey>* sAllowedAttributes;
 };
 
 nsTHashtable<nsISupportsHashKey>* nsHTMLParanoidFragmentSink::sAllowedTags;
 nsTHashtable<nsISupportsHashKey>* nsHTMLParanoidFragmentSink::sAllowedAttributes;
 
 nsHTMLParanoidFragmentSink::nsHTMLParanoidFragmentSink(PRBool aAllContent):
-  nsHTMLFragmentContentSink(aAllContent), mSkip(PR_FALSE), mProcessStyle(PR_FALSE)
+  nsHTMLFragmentContentSink(aAllContent), mSkip(PR_FALSE),
+  mProcessStyle(PR_FALSE), mInStyle(PR_FALSE)
 {
 }
 
 nsresult
 nsHTMLParanoidFragmentSink::Init()
 {
   nsresult rv = NS_ERROR_FAILURE;
   
@@ -999,17 +1013,37 @@ nsHTMLParanoidFragmentSink::AddAttribute
     }
     
     // skip to the next attribute if we encountered issues with the
     // current value
     if (NS_FAILED(rv)) {
       continue;
     }
 
-    if (nodeType == eHTMLTag_a && keyAtom == nsGkAtoms::name) {
+    // Filter unsafe stuff from style attributes if they're allowed
+    if (mProcessStyle && keyAtom == nsGkAtoms::style) {
+      if (!baseURI) {
+        baseURI = aContent->GetBaseURI();
+      }
+      nsCSSParser parser;
+      nsCOMPtr<nsICSSStyleRule> rule;
+      rv = parser.ParseStyleAttribute(aNode.GetValueAt(i),
+                                      mTargetDocument->GetDocumentURI(),
+                                      baseURI,
+                                      mTargetDocument->NodePrincipal(),
+                                      getter_AddRefs(rule));
+      if (NS_SUCCEEDED(rv)) {
+        nsAutoString cleanValue;
+        SanitizeStyleRule(rule, cleanValue);
+        aContent->SetAttr(kNameSpaceID_None, keyAtom, cleanValue, PR_FALSE);
+      } else {
+        // we couldn't sanitize the style attribute, ignore it
+        continue;
+      }
+    } else if (nodeType == eHTMLTag_a && keyAtom == nsGkAtoms::name) {
       NS_ConvertUTF16toUTF8 cname(v);
       NS_ConvertUTF8toUTF16 uv(nsUnescape(cname.BeginWriting()));
       // Add attribute to content
       aContent->SetAttr(kNameSpaceID_None, keyAtom, uv, PR_FALSE);
     } else {
       // Add attribute to content
       aContent->SetAttr(kNameSpaceID_None, keyAtom, v, PR_FALSE);
     }
@@ -1038,16 +1072,20 @@ nsHTMLParanoidFragmentSink::OpenContaine
   // not on whitelist
   if (!sAllowedTags || !sAllowedTags->GetEntry(name)) {
     // unless it's style, and we're allowing it
     if (!mProcessStyle || name != nsGkAtoms::style) {
       return NS_OK;
     }
   }
 
+  if (type == eHTMLTag_style) {
+    mInStyle = PR_TRUE;
+  }
+
   return nsHTMLFragmentContentSink::OpenContainer(aNode);
 }
 
 NS_IMETHODIMP
 nsHTMLParanoidFragmentSink::CloseContainer(const nsHTMLTag aTag)
 {
   nsresult rv = NS_OK;
 
@@ -1063,19 +1101,127 @@ nsHTMLParanoidFragmentSink::CloseContain
   // not on whitelist
   if (!sAllowedTags || !sAllowedTags->GetEntry(name)) {
     // unless it's style, and we're allowing it
     if (!mProcessStyle || name != nsGkAtoms::style) {
       return NS_OK;
     }
   }
 
+  if (mInStyle && name == nsGkAtoms::style) {
+    mInStyle = PR_FALSE;
+
+    // Flush the text to make sure that the style text is complete.
+    FlushText();
+
+    // sanitizedStyleText will hold the permitted CSS text.
+    // We use a white-listing approach, so we explicitly allow
+    // the CSS style and font-face rule types.  We also clear
+    // -moz-binding CSS properties.
+    nsAutoString sanitizedStyleText;
+    nsIContent* style = GetCurrentContent();
+    if (style) {
+      // styleText will hold the text inside the style element.
+      nsAutoString styleText;
+      nsContentUtils::GetNodeTextContent(style, PR_FALSE, styleText);
+      // Create a unichar input stream for the CSS parser.
+      nsCOMPtr<nsIUnicharInputStream> uin;
+      rv = nsSimpleUnicharStreamFactory::GetInstance()->
+        CreateInstanceFromString(styleText, getter_AddRefs(uin));
+      if (NS_SUCCEEDED(rv)) {
+        // Create a sheet to hold the parsed CSS
+        nsRefPtr<nsCSSStyleSheet> sheet;
+        rv = NS_NewCSSStyleSheet(getter_AddRefs(sheet));
+        if (NS_SUCCEEDED(rv)) {
+          nsCOMPtr<nsIURI> baseURI = style->GetBaseURI();
+          sheet->SetURIs(mTargetDocument->GetDocumentURI(), nsnull, baseURI);
+          sheet->SetPrincipal(mTargetDocument->NodePrincipal());
+          // Create the CSS parser, and parse the CSS text.
+          nsCSSParser parser(nsnull, sheet);
+          rv = parser.Parse(uin, mTargetDocument->GetDocumentURI(),
+                            baseURI, mTargetDocument->NodePrincipal(),
+                            0, PR_FALSE);
+          // Mark the sheet as complete.
+          if (NS_SUCCEEDED(rv)) {
+            sheet->SetModified(PR_FALSE);
+            sheet->SetComplete();
+          }
+          if (NS_SUCCEEDED(rv)) {
+            // Loop through all the rules found in the CSS text
+            PRInt32 ruleCount = sheet->StyleRuleCount();
+            for (PRInt32 i = 0; i < ruleCount; ++i) {
+              nsRefPtr<nsICSSRule> rule;
+              rv = sheet->GetStyleRuleAt(i, *getter_AddRefs(rule));
+              if (NS_FAILED(rv))
+                continue;
+              NS_ASSERTION(rule, "We should have a rule by now");
+              PRInt32 type;
+              rv = rule->GetType(type);
+              if (NS_FAILED(rv))
+                continue;
+              switch (type) {
+                case nsICSSRule::UNKNOWN_RULE:
+                case nsICSSRule::CHARSET_RULE:
+                case nsICSSRule::IMPORT_RULE:
+                case nsICSSRule::MEDIA_RULE:
+                case nsICSSRule::PAGE_RULE:
+                  // Ignore these rule types.
+                  break;
+                case nsICSSRule::NAMESPACE_RULE:
+                case nsICSSRule::FONT_FACE_RULE: {
+                  // Append @namespace and @font-face rules verbatim.
+                  nsAutoString cssText;
+                  nsCOMPtr<nsIDOMCSSRule> styleRule = do_QueryInterface(rule);
+                  if (styleRule) {
+                    rv = styleRule->GetCssText(cssText);
+                    if (NS_SUCCEEDED(rv)) {
+                      sanitizedStyleText.Append(cssText);
+                    }
+                  }
+                  break;
+                }
+                case nsICSSRule::STYLE_RULE: {
+                  // For style rules, we will just look for and remove the
+                  // -moz-binding properties.
+                  nsCOMPtr<nsICSSStyleRule> styleRule = do_QueryInterface(rule);
+                  NS_ASSERTION(styleRule, "Must be a style rule");
+                  nsAutoString decl;
+                  SanitizeStyleRule(styleRule, decl);
+                  rv = styleRule->GetCssText(decl);
+                  // Only add the rule when sanitized.
+                  if (NS_SUCCEEDED(rv)) {
+                    sanitizedStyleText.Append(decl);
+                  }
+                }
+              }
+            }
+          }
+        }
+      }
+      // Replace the style element content with its sanitized style text
+      nsContentUtils::SetNodeTextContent(style, sanitizedStyleText, PR_TRUE);
+    }
+  }
+
   return nsHTMLFragmentContentSink::CloseContainer(aTag);
 }
 
+void
+nsHTMLParanoidFragmentSink::SanitizeStyleRule(nsICSSStyleRule *aRule, nsAutoString &aRuleText)
+{
+  aRuleText.Truncate();
+  nsCSSDeclaration *style = aRule->GetDeclaration();
+  if (style) {
+    nsresult rv = style->RemoveProperty(eCSSProperty_binding);
+    if (NS_SUCCEEDED(rv)) {
+      style->ToString(aRuleText);
+    }
+  }
+}
+
 NS_IMETHODIMP
 nsHTMLParanoidFragmentSink::AddLeaf(const nsIParserNode& aNode)
 {
   NS_ENSURE_TRUE(mNodeInfoManager, NS_ERROR_NOT_INITIALIZED);
   
   nsresult rv = NS_OK;
 
   if (mSkip) {
