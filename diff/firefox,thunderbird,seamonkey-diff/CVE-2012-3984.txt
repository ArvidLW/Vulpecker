diff --git a/layout/base/nsDocumentViewer.cpp b/layout/base/nsDocumentViewer.cpp
--- a/layout/base/nsDocumentViewer.cpp
+++ b/layout/base/nsDocumentViewer.cpp
@@ -176,17 +176,17 @@ static const char sPrintOptionsContractI
 
 // FrameSet
 #include "nsIDocument.h"
 
 //focus
 #include "nsIDOMEventTarget.h"
 #include "nsIDOMFocusListener.h"
 #include "nsISelectionController.h"
-
+#include "nsComboboxControlFrame.h"
 #include "nsBidiUtils.h"
 #include "nsISHEntry.h"
 #include "nsISHistory.h"
 #include "nsISHistoryInternal.h"
 #include "nsIWebNavigation.h"
 #include "nsWeakPtr.h"
 #include "nsEventDispatcher.h"
 
@@ -1299,16 +1299,18 @@ DocumentViewerImpl::PageHide(PRBool aIsU
   }
 
 #ifdef MOZ_XUL
   // look for open menupopups and close them after the unload event, in case
   // the unload event listeners open any new popups
   nsContentUtils::HidePopupsInDocument(mDocument);
 #endif
 
+  nsComboboxControlFrame::CloseOpenPopup(mPresContext);
+
   return NS_OK;
 }
 
 static void
 AttachContainerRecurse(nsIDocShell* aShell)
 {
   nsCOMPtr<nsIContentViewer> viewer;
   aShell->GetContentViewer(getter_AddRefs(viewer));
diff --git a/layout/forms/nsComboboxControlFrame.cpp b/layout/forms/nsComboboxControlFrame.cpp
--- a/layout/forms/nsComboboxControlFrame.cpp
+++ b/layout/forms/nsComboboxControlFrame.cpp
@@ -155,17 +155,18 @@ class nsComboButtonListener: public nsID
   nsComboboxControlFrame* mComboBox;
 };
 
 NS_IMPL_ISUPPORTS2(nsComboButtonListener,
                    nsIDOMMouseListener,
                    nsIDOMEventListener)
 
 // static class data member for Bug 32920
-nsComboboxControlFrame * nsComboboxControlFrame::mFocused = nsnull;
+nsComboboxControlFrame* nsComboboxControlFrame::sFocused = nsnull;
+nsComboboxControlFrame* nsComboboxControlFrame::sOpened = nsnull;
 
 nsIFrame*
 NS_NewComboboxControlFrame(nsIPresShell* aPresShell, nsStyleContext* aContext, PRUint32 aStateFlags)
 {
   nsComboboxControlFrame* it = new (aPresShell) nsComboboxControlFrame(aContext);
 
   if (it) {
     // set the state flags (if any are provided)
@@ -284,16 +285,22 @@ nsComboboxControlFrame::nsComboboxContro
 
   REFLOW_COUNTER_INIT()
 }
 
 //--------------------------------------------------------------
 nsComboboxControlFrame::~nsComboboxControlFrame()
 {
   REFLOW_COUNTER_DUMP("nsCCF");
+  if (sFocused == this) {
+    sFocused = nsnull;
+  }
+  if (sOpened == this) {
+    sOpened = nsnull;
+  }
 }
 
 //--------------------------------------------------------------
 
 NS_QUERYFRAME_HEAD(nsComboboxControlFrame)
   NS_QUERYFRAME_ENTRY(nsIComboboxControlFrame)
   NS_QUERYFRAME_ENTRY(nsIFormControlFrame)
   NS_QUERYFRAME_ENTRY(nsIAnonymousContentCreator)
@@ -317,19 +324,19 @@ nsComboboxControlFrame::CreateAccessible
 #endif
 
 void 
 nsComboboxControlFrame::SetFocus(PRBool aOn, PRBool aRepaint)
 {
   nsWeakFrame weakFrame(this);
   if (aOn) {
     nsListControlFrame::ComboboxFocusSet();
-    mFocused = this;
+    sFocused = this;
   } else {
-    mFocused = nsnull;
+    sFocused = nsnull;
     if (mDroppedDown) {
       mListControlFrame->ComboboxFinish(mDisplayedIndex); // might destroy us
       if (!weakFrame.IsAlive()) {
         return;
       }
     }
     // May delete |this|.
     mListControlFrame->FireOnChange();
@@ -733,19 +740,26 @@ nsComboboxControlFrame::ShowDropDown(PRB
   nsEventStates eventStates = mContent->IntrinsicState();
   if (eventStates.HasState(NS_EVENT_STATE_DISABLED)) {
     return;
   }
 
   if (!mDroppedDown && aDoDropDown) {
     if (mListControlFrame) {
       mListControlFrame->SyncViewWithFrame();
+    }                  
+    if (sOpened) {
+      nsWeakFrame weakFrame(this);
+      CloseOpenPopup(sOpened->PresContext());
+      ENSURE_TRUE(weakFrame.IsAlive());
     }
+    sOpened = this;
     ShowList(aDoDropDown); // might destroy us
   } else if (mDroppedDown && !aDoDropDown) {
+    sOpened = nsnull;
     ShowList(aDoDropDown); // might destroy us
   }
 }
 
 void
 nsComboboxControlFrame::SetDropDown(nsIFrame* aDropDownFrame)
 {
   mDropdownFrame = aDropDownFrame;
@@ -1382,17 +1396,17 @@ nsComboboxControlFrame::BuildDisplayList
   return DisplaySelectionOverlay(aBuilder, aLists.Content());
 }
 
 void nsComboboxControlFrame::PaintFocus(nsIRenderingContext& aRenderingContext,
                                         nsPoint aPt)
 {
   /* Do we need to do anything? */
   nsEventStates eventStates = mContent->IntrinsicState();
-  if (eventStates.HasState(NS_EVENT_STATE_DISABLED) || mFocused != this)
+  if (eventStates.HasState(NS_EVENT_STATE_DISABLED) || sFocused != this)
     return;
 
   aRenderingContext.PushState();
   nsRect clipRect = mDisplayFrame->GetRect() + aPt;
   aRenderingContext.SetClipRect(clipRect, nsClipCombine_kIntersect);
 
   // REVIEW: Why does the old code paint mDisplayFrame again? We've
   // already painted it in the children above. So clipping it here won't do
diff --git a/layout/forms/nsComboboxControlFrame.h b/layout/forms/nsComboboxControlFrame.h
--- a/layout/forms/nsComboboxControlFrame.h
+++ b/layout/forms/nsComboboxControlFrame.h
@@ -214,16 +214,25 @@ public:
     { *aShouldRollup = PR_FALSE; return NS_OK;}
 
   //nsIStatefulFrame
   NS_IMETHOD SaveState(SpecialStateID aStateID, nsPresState** aState);
   NS_IMETHOD RestoreState(nsPresState* aState);
 
   static PRBool ToolkitHasNativePopup();
 
+  static void CloseOpenPopup(nsPresContext* aCtx)
+  {
+    if (sOpened && sOpened->PresContext() == aCtx) {
+      nsComboboxControlFrame* f = sOpened;
+      sOpened = nsnull;
+      f->ShowDropDown(PR_FALSE);
+    }
+  }
+
 protected:
 
   // Utilities
   nsresult ReflowDropdown(nsPresContext*          aPresContext, 
                           const nsHTMLReflowState& aReflowState);
 
   // Helper for GetMinWidth/GetPrefWidth
   nscoord GetIntrinsicWidth(nsIRenderingContext* aRenderingContext,
@@ -282,16 +291,18 @@ protected:
   nsString              mDisplayedOptionText;
 
   // make someone to listen to the button. If its programmatically pressed by someone like Accessibility
   // then open or close the combo box.
   nsCOMPtr<nsIDOMMouseListener> mButtonListener;
 
   // static class data member for Bug 32920
   // only one control can be focused at a time
-  static nsComboboxControlFrame * mFocused;
+  static nsComboboxControlFrame* sFocused;
+
+  static nsComboboxControlFrame* sOpened;
 
 #ifdef DO_REFLOW_COUNTER
   PRInt32 mReflowId;
 #endif
 };
 
 #endif

