diff --git a/content/base/src/nsGenericElement.cpp b/content/base/src/nsGenericElement.cpp
--- a/content/base/src/nsGenericElement.cpp
+++ b/content/base/src/nsGenericElement.cpp
@@ -3864,16 +3864,20 @@ nsGenericElement::doReplaceOrInsertBefor
     PRBool appending = aParent && (insPos == container->GetChildCount());
     PRBool firstInsPos = insPos;
 
     // Iterate through the fragment's children, and insert them in the new
     // parent
     for (i = 0; i < count; ++i, ++insPos) {
       nsIContent* childContent = fragChildren[i];
 
+      if (!container->HasSameOwnerDoc(childContent)) {
+        return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
+      }
+
       // XXXbz how come no reparenting here?  That seems odd...
       // Insert the child.
       res = container->InsertChildAt(childContent, insPos, PR_FALSE);
       if (NS_FAILED(res)) {
         // Make sure to notify on any children that we did succeed to insert
         if (appending && i != 0) {
           nsNodeUtils::ContentAppended(aParent, firstInsPos);
         }
@@ -3960,16 +3964,20 @@ nsGenericElement::doReplaceOrInsertBefor
         if (newContent->GetNodeParent() ||
             !IsAllowedAsChild(newContent, nodeType, aParent, aDocument,
                               PR_FALSE, refContent)) {
           return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
         }
       }
     }
 
+    if (!container->HasSameOwnerDoc(newContent)) {
+      return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
+    }
+
     if (!newContent->IsNodeOfType(eXUL)) {
       nsContentUtils::ReparentContentWrapper(newContent, aParent,
                                              container->GetOwnerDoc(),
                                              container->GetOwnerDoc());
     }
 
     res = container->InsertChildAt(newContent, insPos, PR_TRUE);
     NS_ENSURE_SUCCESS(res, res);

