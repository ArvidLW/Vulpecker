diff --git a/content/base/src/nsGenericDOMDataNode.cpp b/content/base/src/nsGenericDOMDataNode.cpp
--- a/content/base/src/nsGenericDOMDataNode.cpp
+++ b/content/base/src/nsGenericDOMDataNode.cpp
@@ -297,8 +297,7 @@ nsGenericDOMDataNode::SubstringData(PRUi
 {
   aReturn.Truncate();
 
-  // XXX add <0 checks if types change
-  PRUint32 textLength = PRUint32( mText.GetLength() );
+  PRUint32 textLength = mText.GetLength();
   if (aStart > textLength) {
     return NS_ERROR_DOM_INDEX_SIZE_ERR;
   }
@@ -366,6 +365,20 @@ nsGenericDOMDataNode::SetTextInternal(PR
     return NS_ERROR_DOM_INDEX_SIZE_ERR;
   }
 
+  if (aCount > textLength - aOffset) {
+    aCount = textLength - aOffset;
+  }
+
+  PRUint32 endOffset = aOffset + aCount;
+
+  // Make sure the text fragment can hold the new data.
+  if (aLength > aCount && !mText.CanGrowBy(aLength - aCount)) {
+    // This exception isn't per spec, but the spec doesn't actually
+    // say what to do here.
+
+    return NS_ERROR_DOM_DOMSTRING_SIZE_ERR;
+  }
+
   nsIDocument *document = GetCurrentDoc();
   mozAutoDocUpdate updateBatch(document, UPDATE_CONTENT_MODEL, aNotify);
 
@@ -379,12 +392,6 @@ nsGenericDOMDataNode::SetTextInternal(PR
     oldValue = GetCurrentValueAtom();
   }
     
-  PRUint32 endOffset = aOffset + aCount;
-  if (endOffset > textLength) {
-    aCount = textLength - aOffset;
-    endOffset = textLength;
-  }
-
   if (aNotify) {
     CharacterDataChangeInfo info = {
       aOffset == textLength,
@@ -412,10 +419,10 @@ nsGenericDOMDataNode::SetTextInternal(PR
     NS_ENSURE_TRUE(to, NS_ERROR_OUT_OF_MEMORY);
 
     // Copy over appropriate data
-    if (0 != aOffset) {
+    if (aOffset) {
       mText.CopyTo(to, 0, aOffset);
     }
-    if (0 != aLength) {
+    if (aLength) {
       memcpy(to + aOffset, aBuffer, aLength * sizeof(PRUnichar));
     }
     if (endOffset != textLength) {
diff --git a/content/base/src/nsTextFragment.h b/content/base/src/nsTextFragment.h
--- a/content/base/src/nsTextFragment.h
+++ b/content/base/src/nsTextFragment.h
@@ -146,6 +146,11 @@ public:
     return mState.mLength;
   }
 
+  PRBool CanGrowBy(size_t n) const
+  {
+    return n < (1 << 29) && mState.mLength + n < (1 << 29);
+  }
+
   /**
    * Change the contents of this fragment to be a copy of the given
    * buffer.
