diff --git a/netwerk/streamconv/converters/nsIndexedToHTML.cpp b/netwerk/streamconv/converters/nsIndexedToHTML.cpp
--- a/netwerk/streamconv/converters/nsIndexedToHTML.cpp
+++ b/netwerk/streamconv/converters/nsIndexedToHTML.cpp
@@ -146,16 +146,40 @@ nsIndexedToHTML::AsyncConvertData(const 
                                   const char *aToType,
                                   nsIStreamListener *aListener,
                                   nsISupports *aCtxt) {
     return Init(aListener);
 }
 
 NS_IMETHODIMP
 nsIndexedToHTML::OnStartRequest(nsIRequest* request, nsISupports *aContext) {
+    nsString buffer;
+    nsresult rv = DoOnStartRequest(request, aContext, buffer);
+    if (NS_FAILED(rv)) {
+        request->Cancel(rv);
+    }
+    
+    // Push buffer to the listener now, so the initial HTML will not
+    // be parsed in OnDataAvailable().
+
+    rv = mListener->OnStartRequest(request, aContext);
+    if (NS_FAILED(rv)) return rv;
+
+    // The request may have been canceled, and if that happens, we want to
+    // suppress calls to OnDataAvailable.
+    request->GetStatus(&rv);
+    if (NS_FAILED(rv)) return rv;
+
+    rv = FormatInputStream(request, aContext, buffer);
+    return rv;
+}
+
+nsresult
+nsIndexedToHTML::DoOnStartRequest(nsIRequest* request, nsISupports *aContext,
+                                  nsString& aBuffer) {
     nsresult rv;
 
     nsCOMPtr<nsIChannel> channel = do_QueryInterface(request);
     nsCOMPtr<nsIURI> uri;
     rv = channel->GetURI(getter_AddRefs(uri));
     if (NS_FAILED(rv)) return rv;
 
     channel->SetContentType(NS_LITERAL_CSTRING("text/html"));
@@ -665,28 +689,17 @@ nsIndexedToHTML::OnStartRequest(nsIReque
                                     getter_Copies(columnText));
     if (NS_FAILED(rv)) return rv;
     AppendNonAsciiToNCR(columnText, buffer);
     buffer.AppendLiteral("</th>\n"
                          "  </tr>\n"
                          " </thead>\n");
     buffer.AppendLiteral(" <tbody>\n");
 
-    // Push buffer to the listener now, so the initial HTML will not
-    // be parsed in OnDataAvailable().
-
-    rv = mListener->OnStartRequest(request, aContext);
-    if (NS_FAILED(rv)) return rv;
-
-    // The request may have been canceled, and if that happens, we want to
-    // suppress calls to OnDataAvailable.
-    request->GetStatus(&rv);
-    if (NS_FAILED(rv)) return rv;
-
-    rv = FormatInputStream(request, aContext, buffer);
+    aBuffer = buffer;
     return rv;
 }
 
 NS_IMETHODIMP
 nsIndexedToHTML::OnStopRequest(nsIRequest* request, nsISupports *aContext,
                                nsresult aStatus) {
     if (NS_SUCCEEDED(aStatus)) {
         nsString buffer;
diff --git a/netwerk/streamconv/converters/nsIndexedToHTML.h b/netwerk/streamconv/converters/nsIndexedToHTML.h
--- a/netwerk/streamconv/converters/nsIndexedToHTML.h
+++ b/netwerk/streamconv/converters/nsIndexedToHTML.h
@@ -70,17 +70,20 @@ public:
     nsresult Init(nsIStreamListener *aListener);
 
     static nsresult
     Create(nsISupports *aOuter, REFNSIID aIID, void **aResult);
 
 protected:
     
     void FormatSizeString(PRInt64 inSize, nsString& outSizeString);
-    nsresult FormatInputStream(nsIRequest* aRequest, nsISupports *aContext, const nsAString &aBuffer); 
+    nsresult FormatInputStream(nsIRequest* aRequest, nsISupports *aContext, const nsAString &aBuffer);
+    // Helper to properly implement OnStartRequest
+    nsresult DoOnStartRequest(nsIRequest* request, nsISupports *aContext,
+                              nsString& aBuffer);
 
 protected:
     nsCOMPtr<nsIDirIndexParser>     mParser;
     nsCOMPtr<nsIStreamListener>     mListener; // final listener (consumer)
 
     nsCOMPtr<nsIDateTimeFormat> mDateTime;
     nsCOMPtr<nsIStringBundle> mBundle;
 

