diff --git a/image/encoders/bmp/nsBMPEncoder.cpp b/image/encoders/bmp/nsBMPEncoder.cpp
--- a/image/encoders/bmp/nsBMPEncoder.cpp
+++ b/image/encoders/bmp/nsBMPEncoder.cpp
@@ -169,18 +169,19 @@ NS_IMETHODIMP nsBMPEncoder::StartImageEn
   mImageBufferCurr = mImageBufferStart;
 
   EncodeFileHeader();
   EncodeInfoHeader();
 
   return NS_OK;
 }
 
-// Returns the image buffer size
-NS_IMETHODIMP nsBMPEncoder::GetImageBufferSize(PRUint32 *aOutputSize)
+// Returns the number of bytes in the image buffer used.
+// For a BMP file, this is all bytes in the buffer.
+NS_IMETHODIMP nsBMPEncoder::GetImageBufferUsed(PRUint32 *aOutputSize)
 {
   NS_ENSURE_ARG_POINTER(aOutputSize);
   *aOutputSize = mImageBufferSize;
   return NS_OK;
 }
 
 // Returns a pointer to the start of the image buffer
 NS_IMETHODIMP nsBMPEncoder::GetImageBuffer(char **aOutputBuffer)
diff --git a/image/encoders/ico/nsICOEncoder.cpp b/image/encoders/ico/nsICOEncoder.cpp
--- a/image/encoders/ico/nsICOEncoder.cpp
+++ b/image/encoders/ico/nsICOEncoder.cpp
@@ -106,19 +106,20 @@ NS_IMETHODIMP nsICOEncoder::InitFromData
   rv = AddImageFrame(aData, aLength, aWidth, aHeight, aStride,
                      aInputFormat, aOutputOptions);
   NS_ENSURE_SUCCESS(rv, rv);
 
   rv = EndImageEncode();
   return rv;
 }
 
-// Returns the image buffer size
+// Returns the number of bytes in the image buffer used
+// For an ICO file, this is all bytes in the buffer.
 NS_IMETHODIMP 
-nsICOEncoder::GetImageBufferSize(PRUint32 *aOutputSize)
+nsICOEncoder::GetImageBufferUsed(PRUint32 *aOutputSize)
 {
   NS_ENSURE_ARG_POINTER(aOutputSize);
   *aOutputSize = mImageBufferSize;
   return NS_OK;
 }
 
 // Returns a pointer to the start of the image buffer
 NS_IMETHODIMP 
@@ -142,78 +143,78 @@ nsICOEncoder::AddImageFrame(const PRUint
 
     mContainedEncoder = new nsPNGEncoder();
     nsresult rv;
     nsAutoString noParams;
     rv = mContainedEncoder->InitFromData(aData, aLength, aWidth, aHeight,
                                          aStride, aInputFormat, noParams);
     NS_ENSURE_SUCCESS(rv, rv);
 
-    PRUint32 imageBufferSize;
-    mContainedEncoder->GetImageBufferSize(&imageBufferSize);
+    PRUint32 PNGImageBufferSize;
+    mContainedEncoder->GetImageBufferUsed(&PNGImageBufferSize);
     mImageBufferSize = ICONFILEHEADERSIZE + ICODIRENTRYSIZE + 
-                       imageBufferSize;
+                       PNGImageBufferSize;
     mImageBufferStart = static_cast<PRUint8*>(moz_malloc(mImageBufferSize));
     if (!mImageBufferStart) {
       return NS_ERROR_OUT_OF_MEMORY;
     }
     mImageBufferCurr = mImageBufferStart;
-    mICODirEntry.mBytesInRes = imageBufferSize;
+    mICODirEntry.mBytesInRes = PNGImageBufferSize;
 
     EncodeFileHeader();
     EncodeInfoHeader();
 
     char *imageBuffer;
     rv = mContainedEncoder->GetImageBuffer(&imageBuffer);
     NS_ENSURE_SUCCESS(rv, rv);
-    memcpy(mImageBufferCurr, imageBuffer, imageBufferSize);
-    mImageBufferCurr += imageBufferSize;
+    memcpy(mImageBufferCurr, imageBuffer, PNGImageBufferSize);
+    mImageBufferCurr += PNGImageBufferSize;
   } else {
     mContainedEncoder = new nsBMPEncoder();
     nsresult rv;
 
     nsAutoString params;
     params.AppendASCII("bpp=");
     params.AppendInt(mICODirEntry.mBitCount);
 
     rv = mContainedEncoder->InitFromData(aData, aLength, aWidth, aHeight,
                                          aStride, aInputFormat, params);
     NS_ENSURE_SUCCESS(rv, rv);
 
     PRUint32 andMaskSize = ((GetRealWidth() + 31) / 32) * 4 * // row AND mask
                            GetRealHeight(); // num rows
 
-    PRUint32 imageBufferSize;
-    mContainedEncoder->GetImageBufferSize(&imageBufferSize);
+    PRUint32 BMPImageBufferSize;
+    mContainedEncoder->GetImageBufferUsed(&BMPImageBufferSize);
     mImageBufferSize = ICONFILEHEADERSIZE + ICODIRENTRYSIZE + 
-                       imageBufferSize + andMaskSize;
+                       BMPImageBufferSize + andMaskSize;
     mImageBufferStart = static_cast<PRUint8*>(moz_malloc(mImageBufferSize));
     if (!mImageBufferStart) {
       return NS_ERROR_OUT_OF_MEMORY;
     }
     mImageBufferCurr = mImageBufferStart;
 
     // The icon buffer does not include the BFH at all.
-    mICODirEntry.mBytesInRes = imageBufferSize - BFH_LENGTH + andMaskSize;
+    mICODirEntry.mBytesInRes = BMPImageBufferSize - BFH_LENGTH + andMaskSize;
 
     // Encode the icon headers
     EncodeFileHeader();
     EncodeInfoHeader();
 
     char *imageBuffer;
     rv = mContainedEncoder->GetImageBuffer(&imageBuffer);
     NS_ENSURE_SUCCESS(rv, rv);
     memcpy(mImageBufferCurr, imageBuffer + BFH_LENGTH, 
-           imageBufferSize - BFH_LENGTH);
+           BMPImageBufferSize - BFH_LENGTH);
     // We need to fix the BMP height to be *2 for the AND mask
     PRUint32 fixedHeight = GetRealHeight() * 2;
     fixedHeight = NATIVE32_TO_LITTLE(fixedHeight);
     // The height is stored at an offset of 8 from the DIB header
     memcpy(mImageBufferCurr + 8, &fixedHeight, sizeof(fixedHeight));
-    mImageBufferCurr += imageBufferSize - BFH_LENGTH;
+    mImageBufferCurr += BMPImageBufferSize - BFH_LENGTH;
 
     // Calculate rowsize in DWORD's
     PRUint32 rowSize = ((GetRealWidth() + 31) / 32) * 4; // + 31 to round up
     PRInt32 currentLine = GetRealHeight();
     
     // Write out the AND mask
     while (currentLine > 0) {
       currentLine--;
diff --git a/image/encoders/jpeg/nsJPEGEncoder.cpp b/image/encoders/jpeg/nsJPEGEncoder.cpp
--- a/image/encoders/jpeg/nsJPEGEncoder.cpp
+++ b/image/encoders/jpeg/nsJPEGEncoder.cpp
@@ -216,21 +216,21 @@ NS_IMETHODIMP nsJPEGEncoder::InitFromDat
 NS_IMETHODIMP nsJPEGEncoder::StartImageEncode(PRUint32 aWidth,
                                               PRUint32 aHeight,
                                               PRUint32 aInputFormat,
                                               const nsAString& aOutputOptions)
 {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
-// Returns the image buffer size
-NS_IMETHODIMP  nsJPEGEncoder::GetImageBufferSize(PRUint32 *aOutputSize)
+// Returns the number of bytes in the image buffer used.
+NS_IMETHODIMP  nsJPEGEncoder::GetImageBufferUsed(PRUint32 *aOutputSize)
 {
   NS_ENSURE_ARG_POINTER(aOutputSize);
-  *aOutputSize = mImageBufferSize;
+  *aOutputSize = mImageBufferUsed;
   return NS_OK;
 }
 
 // Returns a pointer to the start of the image buffer
 NS_IMETHODIMP nsJPEGEncoder::GetImageBuffer(char **aOutputBuffer)
 {
   NS_ENSURE_ARG_POINTER(aOutputBuffer);
   *aOutputBuffer = reinterpret_cast<char*>(mImageBuffer);
diff --git a/image/encoders/png/nsPNGEncoder.cpp b/image/encoders/png/nsPNGEncoder.cpp
--- a/image/encoders/png/nsPNGEncoder.cpp
+++ b/image/encoders/png/nsPNGEncoder.cpp
@@ -201,21 +201,21 @@ NS_IMETHODIMP nsPNGEncoder::StartImageEn
 
   // XXX: support PLTE, gAMA, tRNS, bKGD?
 
   png_write_info(mPNG, mPNGinfo);
 
   return NS_OK;
 }
 
-// Returns the image buffer size
-NS_IMETHODIMP nsPNGEncoder::GetImageBufferSize(PRUint32 *aOutputSize)
+// Returns the number of bytes in the image buffer used.
+NS_IMETHODIMP nsPNGEncoder::GetImageBufferUsed(PRUint32 *aOutputSize)
 {
   NS_ENSURE_ARG_POINTER(aOutputSize);
-  *aOutputSize = mImageBufferSize;
+  *aOutputSize = mImageBufferUsed;
   return NS_OK;
 }
 
 // Returns a pointer to the start of the image buffer
 NS_IMETHODIMP nsPNGEncoder::GetImageBuffer(char **aOutputBuffer)
 {
   NS_ENSURE_ARG_POINTER(aOutputBuffer);
   *aOutputBuffer = reinterpret_cast<char*>(mImageBuffer);

