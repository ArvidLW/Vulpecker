--- content/base/src/nsDocument.cpp	22 Aug 2008 18:50:55 -0000	3.566.2.40
+++ content/base/src/nsDocument.cpp	19 Nov 2008 02:39:47 -0000
@@ -3018,30 +3018,28 @@ nsDocument::RemoveBinding(nsIDOMElement*
   nsCOMPtr<nsIContent> content(do_QueryInterface(aContent));
   return mBindingManager->RemoveLayeredBinding(content, uri);
 }
 
 NS_IMETHODIMP
 nsDocument::LoadBindingDocument(const nsAString& aURI,
                                 nsIDOMDocument** aResult)
 {
+  *aResult = nsnull;
+
   nsCOMPtr<nsIURI> uri;
   nsresult rv = NS_NewURI(getter_AddRefs(uri), aURI,
                           mCharacterSet.get(),
                           NS_STATIC_CAST(nsIDocument *, this)->GetBaseURI());
 
   NS_ENSURE_SUCCESS(rv, rv);
   
   nsCOMPtr<nsIDocument> doc;
   mBindingManager->LoadBindingDocument(this, uri, getter_AddRefs(doc));
 
-  if (doc) {
-    CallQueryInterface(doc, aResult);
-  }
-  
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsDocument::GetBindingParent(nsIDOMNode* aNode, nsIDOMElement** aResult)
 {
   *aResult = nsnull;
   nsCOMPtr<nsIContent> content(do_QueryInterface(aNode));
diff -u -8 -p -w -r1.204.4.4 nsXBLService.cpp
--- content/xbl/src/nsXBLService.cpp	22 Aug 2008 19:48:18 -0000	1.204.4.4
+++ content/xbl/src/nsXBLService.cpp	19 Nov 2008 02:39:47 -0000
@@ -502,16 +502,26 @@ nsXBLService::~nsXBLService(void)
     gClassTable = nsnull;
 
 #ifdef MOZ_XUL
     NS_IF_RELEASE(gXULCache);
 #endif
   }
 }
 
+static PRBool
+IsSystemPrincipal(nsIPrincipal* aPrincipal)
+{
+  nsCOMPtr<nsIPrincipal> sys;
+  nsresult rv = nsContentUtils::GetSecurityManager()->
+    GetSystemPrincipal(getter_AddRefs(sys));
+  return NS_SUCCEEDED(rv) && sys && sys == aPrincipal;
+  
+}
+
 // This function loads a particular XBL file and installs all of the bindings
 // onto the element.
 NS_IMETHODIMP
 nsXBLService::LoadBindings(nsIContent* aContent, nsIURI* aURL, PRBool aAugmentFlag,
                            nsXBLBinding** aBinding, PRBool* aResolveStyle) 
 { 
   *aBinding = nsnull;
   *aResolveStyle = PR_FALSE;
@@ -541,54 +551,64 @@ nsXBLService::LoadBindings(nsIContent* a
         if (NS_SUCCEEDED(uri->Equals(aURL, &equal)) && equal)
           return NS_OK;
         FlushStyleBindings(aContent);
         binding = nsnull;
       }
     }
   }
 
-  // Security check - remote pages can't load local bindings, except from chrome
+  // Security check - remote pages can't load local or cross-site bindings,
+  // except from chrome
+  nsCOMPtr<nsIPrincipal> loadDocPrincipal = document->GetPrincipal();
+  if (!IsSystemPrincipal(loadDocPrincipal)) {
   nsIURI *docURI = document->GetDocumentURI();
   PRBool isChrome = PR_FALSE;
   rv = docURI->SchemeIs("chrome", &isChrome);
 
   // Not everything with a chrome URI has a system principal.  See bug 160042.
   if (NS_FAILED(rv) || !isChrome) {
     nsIScriptSecurityManager *secMan = nsContentUtils::GetSecurityManager();
 
     rv = secMan->
-      CheckLoadURIWithPrincipal(document->GetPrincipal(), aURL,
+        CheckLoadURIWithPrincipal(loadDocPrincipal, aURL,
                                 nsIScriptSecurityManager::ALLOW_CHROME);
     if (NS_FAILED(rv))
       return rv;
   }
 
   // Content policy check.  We have to be careful to not pass aContent as the
   // context here.  Otherwise, if there is a JS-implemented content policy, we
   // will attempt to wrap the content node, which will try to load XBL bindings
   // for it, if any.  Since we're not done loading this binding yet, that will
   // reenter this method and we'll end up creating a binding and then
   // immediately clobbering it in our table.  That makes things very confused,
   // leading to misbehavior and crashes.
   PRInt16 decision = nsIContentPolicy::ACCEPT;
-  rv = NS_CheckContentLoadPolicy(nsIContentPolicy::TYPE_OTHER,
+    rv = NS_CheckContentLoadPolicy(nsIContentPolicy::TYPE_XBL,
                                  aURL,
                                  docURI,
                                  document,        // context
                                  EmptyCString(),  // mime guess
                                  nsnull,          // extra
                                  &decision);
 
   if (NS_SUCCEEDED(rv) && !NS_CP_ACCEPTED(decision))
     rv = NS_ERROR_NOT_AVAILABLE;
-
   if (NS_FAILED(rv))
     return rv;
 
+    PRBool chrome;
+    if (NS_FAILED(aURL->SchemeIs("chrome", &chrome)) || !chrome) {
+      rv = nsContentUtils::GetSecurityManager()->
+        CheckSameOriginURI(docURI, aURL);
+      NS_ENSURE_SUCCESS(rv, rv);
+    }
+  }
+
   PRBool ready;
   nsRefPtr<nsXBLBinding> newBinding;
   if (NS_FAILED(rv = GetBinding(aContent, aURL, PR_FALSE, &ready,
                                 getter_AddRefs(newBinding)))) {
     return rv;
   }
 
   if (!newBinding) {
@@ -1031,16 +1051,24 @@ nsXBLService::LoadBindingDocumentInfo(ns
   rv = aBindingURI->Clone(getter_AddRefs(uriClone));
   NS_ENSURE_SUCCESS(rv, rv);
   
   nsCOMPtr<nsIURL> documentURI(do_QueryInterface(uriClone, &rv));
   NS_ENSURE_TRUE(documentURI, rv);
 
   documentURI->SetRef(EmptyCString());
 
+  if (aBoundDocument) {
+    rv = nsContentUtils::GetSecurityManager()->
+      CheckLoadURIWithPrincipal(aBoundDocument->GetPrincipal(), aBindingURI,
+                                nsIScriptSecurityManager::ALLOW_CHROME);
+    if (NS_FAILED(rv))
+      return rv;
+  }
+
 #ifdef MOZ_XUL
   // We've got a file.  Check our XBL document cache.
   PRBool useXULCache;
   gXULCache->GetEnabled(&useXULCache);
 
   if (useXULCache) {
     // The first line of defense is the chrome cache.  
     // This cache crosses the entire product, so that any XBL bindings that are
