--- xpcom/io/nsEscape.cpp	25 Aug 2008 20:29:18 -0000	1.42
+++ xpcom/io/nsEscape.cpp	24 Oct 2008 23:37:35 -0000
@@ -216,20 +216,25 @@ NS_COM PRInt32 nsUnescapeCount(char * st
     *dst = 0;
     return (int)(dst - str);
 
 } /* NET_UnEscapeCnt */
 
 
 NS_COM char *
 nsEscapeHTML(const char * string)
 {
+    char *rv = nsnull;
 	/* XXX Hardcoded max entity len. The +1 is for the trailing null. */
-	char *rv = (char *) nsMemory::Alloc(strlen(string) * 6 + 1);
+    PRUint32 len = PL_strlen(string);
+    if (len >= (PR_UINT32_MAX / 6))
+      return nsnull;
+
+    rv = (char *)NS_Alloc( (6 * len) + 1 );
 	char *ptr = rv;
 
 	if(rv)
 	  {
 		for(; *string != '\0'; string++)
 		  {
 			if(*string == '<')
 			  {
 				*ptr++ = '&';
@@ -283,18 +288,22 @@ nsEscapeHTML(const char * string)
 NS_COM PRUnichar *
 nsEscapeHTML2(const PRUnichar *aSourceBuffer, PRInt32 aSourceBufferLen)
 {
   // if the caller didn't calculate the length
   if (aSourceBufferLen == -1) {
     aSourceBufferLen = nsCRT::strlen(aSourceBuffer); // ...then I will
   }
 
   /* XXX Hardcoded max entity len. */
+  if (aSourceBufferLen >=
+      ((PR_UINT32_MAX / (6 * sizeof(PRUnichar))) + sizeof(PRUnichar)))
+    return nsnull;
+
   PRUnichar *resultBuffer = (PRUnichar *)nsMemory::Alloc(aSourceBufferLen *
                             6 * sizeof(PRUnichar) + sizeof(PRUnichar('\0')));
   PRUnichar *ptr = resultBuffer;
 
   if (resultBuffer) {
     PRInt32 i;
 
     for(i = 0; i < aSourceBufferLen; i++) {
       if(aSourceBuffer[i] == '<') {
