diff --git a/toolkit/components/downloads/src/nsDownloadManager.cpp b/toolkit/components/downloads/src/nsDownloadManager.cpp
--- a/toolkit/components/downloads/src/nsDownloadManager.cpp
+++ b/toolkit/components/downloads/src/nsDownloadManager.cpp
@@ -2106,20 +2106,16 @@ nsresult
 nsDownload::SetState(DownloadState aState)
 {
   NS_ASSERTION(mDownloadState != aState,
                "Trying to set the download state to what it already is set to!");
 
   PRInt16 oldState = mDownloadState;
   mDownloadState = aState;
 
-  nsresult rv;
-
-  nsCOMPtr<nsIPrefBranch> pref = do_GetService(NS_PREFSERVICE_CONTRACTID);
-
   // We don't want to lose access to our member variables
   nsRefPtr<nsDownload> kungFuDeathGrip = this;
 
   // When the state changed listener is dispatched, queries to the database and
   // the download manager api should reflect what the nsIDownload object would
   // return. So, if a download is done (finished, canceled, etc.), it should
   // first be removed from the current downloads.  We will also have to update
   // the database *before* notifying listeners.  At this point, you can safely
@@ -2141,21 +2137,29 @@ nsDownload::SetState(DownloadState aStat
       if (NS_SUCCEEDED(rv))
         break;
       mDownloadState = aState = nsIDownloadManager::DOWNLOAD_FINISHED;
     }
 #endif
     case nsIDownloadManager::DOWNLOAD_FINISHED:
     {
       // Do what exthandler would have done if necessary
-      (void)ExecuteDesiredAction();
+      nsresult rv = ExecuteDesiredAction();
+      if (NS_FAILED(rv)) {
+        // We've failed to execute the desired action.  As a result, we should
+        // fail the download so the user can try again.
+        (void)FailDownload(rv, nsnull);
+        return rv;
+      }
 
       // Now that we're done with handling the download, clean it up
       Finalize();
 
+      nsCOMPtr<nsIPrefBranch> pref(do_GetService(NS_PREFSERVICE_CONTRACTID));
+
       // Master pref to control this function.
       PRBool showTaskbarAlert = PR_TRUE;
       if (pref)
         pref->GetBoolPref(PREF_BDM_SHOWALERTONCOMPLETE, &showTaskbarAlert);
 
       if (showTaskbarAlert) {
         PRInt32 alertInterval = 2000;
         if (pref)
@@ -2238,17 +2242,17 @@ nsDownload::SetState(DownloadState aStat
     }
     break;
   default:
     break;
   }
 
   // Before notifying the listener, we must update the database so that calls
   // to it work out properly.
-  rv = UpdateDB();
+  nsresult rv = UpdateDB();
   NS_ENSURE_SUCCESS(rv, rv);
 
   mDownloadManager->NotifyListenersOnDownloadStateChange(oldState, this);
 
   switch (mDownloadState) {
     case nsIDownloadManager::DOWNLOAD_DOWNLOADING:
       // Only send the dl-start event to downloads that are actually starting.
       if (oldState == nsIDownloadManager::DOWNLOAD_QUEUED)
diff --git a/uriloader/exthandler/nsExternalHelperAppService.cpp b/uriloader/exthandler/nsExternalHelperAppService.cpp
--- a/uriloader/exthandler/nsExternalHelperAppService.cpp
+++ b/uriloader/exthandler/nsExternalHelperAppService.cpp
@@ -1882,45 +1882,58 @@ nsresult nsExternalAppHandler::ExecuteDe
       rv = mFinalFileDestination->CreateUnique(nsIFile::NORMAL_FILE_TYPE, 0600);
       if (NS_SUCCEEDED(rv))
       {
         // Source and dest dirs should be == so this should just do a rename
         rv = MoveFile(mFinalFileDestination);
         if (NS_SUCCEEDED(rv))
           rv = OpenWithApplication();
       }
+      else
+      {
+        // Cancel the download and report an error.  We do not want to end up in
+        // a state where it appears that we have a normal download that is
+        // pointing to a file that we did not actually create.
+        nsAutoString path;
+        mTempFile->GetPath(path);
+        SendStatusChange(kWriteError, rv, nsnull, path);
+        Cancel(rv);
+
+        // We still need to notify if we have a progress listener, so we cannot
+        // return at this point.
+      }
     }
     else // Various unknown actions go here too
     {
       // XXX Put progress dialog in barber-pole mode
       //     and change text to say "Copying from:".
       rv = MoveFile(mFinalFileDestination);
       if (NS_SUCCEEDED(rv) && action == nsIMIMEInfo::saveToDisk)
       {
         nsCOMPtr<nsILocalFile> destfile(do_QueryInterface(mFinalFileDestination));
         gExtProtSvc->FixFilePermissions(destfile);
       }
     }
-    
+
     // Notify dialog that download is complete.
     // By waiting till this point, it ensures that the progress dialog doesn't indicate
     // success until we're really done.
     if(mWebProgressListener)
     {
       if (!mCanceled)
       {
         mWebProgressListener->OnProgressChange64(nsnull, nsnull, mProgress, mContentLength, mProgress, mContentLength);
       }
       mWebProgressListener->OnStateChange(nsnull, nsnull,
         nsIWebProgressListener::STATE_STOP |
         nsIWebProgressListener::STATE_IS_REQUEST |
         nsIWebProgressListener::STATE_IS_NETWORK, NS_OK);
     }
   }
-  
+
   return rv;
 }
 
 NS_IMETHODIMP nsExternalAppHandler::GetMIMEInfo(nsIMIMEInfo ** aMIMEInfo)
 {
   *aMIMEInfo = mMimeInfo;
   NS_ADDREF(*aMIMEInfo);
   return NS_OK;
