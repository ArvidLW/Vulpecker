--- content/xul/document/src/nsXULDocument.cpp	5 Mar 2008 21:32:27 -0000	1.818
+++ content/xul/document/src/nsXULDocument.cpp	20 Mar 2008 14:31:50 -0000
@@ -1267,28 +1267,47 @@ nsXULDocument::Persist(const nsAString& 
         nameSpaceID = kNameSpaceID_None;
     }
 
     rv = Persist(element, nameSpaceID, tag);
     if (NS_FAILED(rv)) return rv;
 
     return NS_OK;
 }
 
 
+PRBool
+nsXULDocument::IsCapabilityEnabled(const char* aCapabilityLabel)
+{
+    nsresult rv;
+
+    // NodePrincipal is guarantied to be non-null
+    PRBool enabled = PR_FALSE;
+    rv = NodePrincipal()->IsCapabilityEnabled(aCapabilityLabel, nsnull, &enabled);
+    if (NS_FAILED(rv))
+        return PR_FALSE;
+ 
+    return enabled;
+}
+
+
 nsresult
 nsXULDocument::Persist(nsIContent* aElement, PRInt32 aNameSpaceID,
                        nsIAtom* aAttribute)
 {
+    // For non-chrome documents, persistance is simply broken
+    if (!IsCapabilityEnabled("UniversalBrowserWrite"))
+        return NS_ERROR_NOT_AVAILABLE;
+
     // First make sure we _have_ a local store to stuff the persisted
     // information into. (We might not have one if profile information
     // hasn't been loaded yet...)
-    if (! mLocalStore)
+    if (!mLocalStore)
         return NS_OK;
 
     nsresult rv;
 
     nsCOMPtr<nsIRDFResource> element;
     rv = nsXULContentUtils::GetElementResource(aElement, getter_AddRefs(element));
     if (NS_FAILED(rv)) return rv;
 
     // No ID, so nothing to persist.
     if (! element)
@@ -2059,27 +2078,40 @@ nsXULDocument::PrepareToLoadPrototype(ns
 
     *aResult = parser;
     NS_ADDREF(*aResult);
     return NS_OK;
 }
 
 
 nsresult
 nsXULDocument::ApplyPersistentAttributes()
 {
+    // For non-chrome documents, persistance is simply broken
+    if (!IsCapabilityEnabled("UniversalBrowserRead"))
+        return NS_ERROR_NOT_AVAILABLE;
+
     // Add all of the 'persisted' attributes into the content
     // model.
-    if (! mLocalStore)
+    if (!mLocalStore)
         return NS_OK;
 
     mApplyingPersistedAttrs = PR_TRUE;
+    ApplyPersistentAttributesInternal();
+    mApplyingPersistedAttrs = PR_FALSE;
+
+    return NS_OK;
+}
+
 
+nsresult 
+nsXULDocument::ApplyPersistentAttributesInternal()
+{
     nsCOMArray<nsIContent> elements;
 
     nsCAutoString docurl;
     mDocumentURI->GetSpec(docurl);
 
     nsCOMPtr<nsIRDFResource> doc;
     gRDFService->GetResource(docurl, getter_AddRefs(doc));
 
     nsCOMPtr<nsISimpleEnumerator> persisted;
     mLocalStore->GetTargets(doc, kNC_persist, PR_TRUE, getter_AddRefs(persisted));
@@ -2112,22 +2144,20 @@ nsXULDocument::ApplyPersistentAttributes
 
         // This will clear the array if there are no elements.
         GetElementsForID(id, elements);
 
         if (!elements.Count())
             continue;
 
         ApplyPersistentAttributesToElements(resource, elements);
     }
 
-    mApplyingPersistedAttrs = PR_FALSE;
-
     return NS_OK;
 }
 
 
 nsresult
 nsXULDocument::ApplyPersistentAttributesToElements(nsIRDFResource* aResource,
                                                    nsCOMArray<nsIContent>& aElements)
 {
     nsresult rv;
 
@@ -3020,22 +3050,21 @@ nsXULDocument::ResumeWalk()
         if (shouldReturn)
             return NS_OK;
         overlayURI.swap(uri);
     }
 
     // If we get here, there is nothing left for us to walk. The content
     // model is built and ready for layout.
     rv = ResolveForwardReferences();
     if (NS_FAILED(rv)) return rv;
 
-    rv = ApplyPersistentAttributes();
-    if (NS_FAILED(rv)) return rv;
+    ApplyPersistentAttributes();
 
     mStillWalking = PR_FALSE;
     if (mPendingSheets == 0) {
         rv = DoneWalking();
     }
     return rv;
 }
 
 nsresult
 nsXULDocument::DoneWalking()
--- content/xul/document/src/nsXULDocument.h	10 Feb 2008 05:19:42 -0000	1.204
+++ content/xul/document/src/nsXULDocument.h	20 Mar 2008 14:31:50 -0000
@@ -194,20 +194,21 @@ protected:
     PrepareToLoadPrototype(nsIURI* aURI,
                            const char* aCommand,
                            nsIPrincipal* aDocumentPrincipal,
                            nsIParser** aResult);
 
     nsresult 
     LoadOverlayInternal(nsIURI* aURI, PRBool aIsDynamic, PRBool* aShouldReturn,
                         PRBool* aFailureFromContent);
 
     nsresult ApplyPersistentAttributes();
+    nsresult ApplyPersistentAttributesInternal();
     nsresult ApplyPersistentAttributesToElements(nsIRDFResource* aResource,
                                                  nsCOMArray<nsIContent>& aElements);
 
     nsresult
     AddElementToDocumentPre(nsIContent* aElement);
 
     nsresult
     AddElementToDocumentPost(nsIContent* aElement);
 
     nsresult
@@ -230,20 +231,23 @@ protected:
 
     static nsIRDFService* gRDFService;
     static nsIRDFResource* kNC_persist;
     static nsIRDFResource* kNC_attribute;
     static nsIRDFResource* kNC_value;
 
     static nsXULPrototypeCache* gXULCache;
 
     static PRLogModuleInfo* gXULLog;
 
+    PRBool
+    IsCapabilityEnabled(const char* aCapabilityLabel);
+
     nsresult
     Persist(nsIContent* aElement, PRInt32 aNameSpaceID, nsIAtom* aAttribute);
 
     // IMPORTANT: The ownership implicit in the following member
     // variables has been explicitly checked and set using nsCOMPtr
     // for owning pointers and raw COM interface pointers for weak
     // (ie, non owning) references. If you add any members to this
     // class, please make the ownership explicit (pinkerton, scc).
     // NOTE, THIS IS STILL IN PROGRESS, TALK TO PINK OR SCC BEFORE
     // CHANGING
