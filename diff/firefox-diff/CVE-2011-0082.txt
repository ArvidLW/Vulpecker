diff --git a/security/manager/ssl/src/nsNSSCertificate.cpp b/security/manager/ssl/src/nsNSSCertificate.cpp
--- a/security/manager/ssl/src/nsNSSCertificate.cpp
+++ b/security/manager/ssl/src/nsNSSCertificate.cpp
@@ -125,16 +125,17 @@ nsNSSCertificate::InitFromDER(char* cert
   mCert = aCert;
   return true;
 }
 
 nsNSSCertificate::nsNSSCertificate(CERTCertificate* cert,
                                    SECOidTag* evOidPolicy)
   : mCert(nullptr)
   , mPermDelete(false)
+  , mCachedEVStatusIsStale(false)
   , mCertType(CERT_TYPE_NOT_YET_INITIALIZED)
   , mCachedEVStatus(ev_status_unknown)
 {
 #if defined(DEBUG)
   if (GeckoProcessType_Default != XRE_GetProcessType())
     NS_ERROR("Trying to initialize nsNSSCertificate in a non-chrome process!");
 #endif
 
@@ -154,16 +155,17 @@ nsNSSCertificate::nsNSSCertificate(CERTC
       mCachedEVOidTag = *evOidPolicy;
     }
   }
 }
 
 nsNSSCertificate::nsNSSCertificate() :
   mCert(nullptr),
   mPermDelete(false),
+  mCachedEVStatusIsStale(false),
   mCertType(CERT_TYPE_NOT_YET_INITIALIZED),
   mCachedEVStatus(ev_status_unknown)
 {
   if (GeckoProcessType_Default != XRE_GetProcessType())
     NS_ERROR("Trying to initialize nsNSSCertificate in a non-chrome process!");
 }
 
 nsNSSCertificate::~nsNSSCertificate()
@@ -1434,17 +1436,19 @@ nsNSSCertificate::getValidEVOidTag(SECOi
     return NS_OK;
   }
 
   nsresult rv = hasValidEVOidTag(resultOidTag, validEV);
   if (NS_SUCCEEDED(rv)) {
     if (validEV) {
       mCachedEVOidTag = resultOidTag;
     }
-    mCachedEVStatus = validEV ? ev_status_valid : ev_status_invalid;
+    if (!mCachedEVStatusIsStale || validEV) {
+      mCachedEVStatus = validEV ? ev_status_valid : ev_status_invalid;
+    }
   }
   return rv;
 }
 
 #endif // MOZ_NO_EV_CERTS
 
 NS_IMETHODIMP
 nsNSSCertificate::GetIsExtendedValidation(bool* aIsEV)
@@ -1901,17 +1905,18 @@ nsNSSCertListEnumerator::GetNext(nsISupp
   return NS_OK;
 }
 
 // NB: This serialization must match that of nsNSSCertificateFakeTransport.
 NS_IMETHODIMP
 nsNSSCertificate::Write(nsIObjectOutputStream* aStream)
 {
   NS_ENSURE_STATE(mCert);
-  nsresult rv = aStream->Write32(static_cast<uint32_t>(mCachedEVStatus));
+  uint32_t ev = ev_status_unknown;
+  nsresult rv = aStream->Write32(static_cast<uint32_t>(ev));
   if (NS_FAILED(rv)) {
     return rv;
   }
   rv = aStream->Write32(mCert->derCert.len);
   if (NS_FAILED(rv)) {
     return rv;
   }
   return aStream->WriteByteArray(mCert->derCert.data, mCert->derCert.len);
@@ -1948,16 +1953,19 @@ nsNSSCertificate::Read(nsIObjectInputStr
   if (NS_FAILED(rv)) {
     return rv;
   }
 
   if (!InitFromDER(const_cast<char*>(str.get()), len)) {
     return NS_ERROR_UNEXPECTED;
   }
 
+  if (mCachedEVStatus == ev_status_unknown) {
+    mCachedEVStatusIsStale = true;
+  }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsNSSCertificate::GetInterfaces(uint32_t* count, nsIID*** array)
 {
   *count = 0;
   *array = nullptr;
diff --git a/security/manager/ssl/src/nsNSSCertificate.h b/security/manager/ssl/src/nsNSSCertificate.h
--- a/security/manager/ssl/src/nsNSSCertificate.h
+++ b/security/manager/ssl/src/nsNSSCertificate.h
@@ -49,16 +49,17 @@ public:
                                   SECOidTag* evOidPolicy = nullptr);
   static nsNSSCertificate* ConstructFromDER(char* certDER, int derLen);
 
 private:
   virtual ~nsNSSCertificate();
 
   mozilla::ScopedCERTCertificate mCert;
   bool             mPermDelete;
+  bool             mCachedEVStatusIsStale;
   uint32_t         mCertType;
   nsresult CreateASN1Struct(nsIASN1Object** aRetVal);
   nsresult CreateTBSCertificateASN1Struct(nsIASN1Sequence** retSequence,
                                           nsINSSComponent* nssComponent);
   nsresult GetSortableDate(PRTime aTime, nsAString& _aSortableDate);
   virtual void virtualDestroyNSSReference();
   void destructorSafeDestroyNSSReference();
   bool InitFromDER(char* certDER, int derLen);  // return false on failure
