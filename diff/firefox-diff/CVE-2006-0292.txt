--- jsemit.c	11 Nov 2005 20:20:19 -0000	3.133
+++ jsemit.c	18 Nov 2005 08:51:18 -0000
@@ -4340,16 +4340,26 @@ js_EmitTree(JSContext *cx, JSCodeGenerat
             } else {
                 if (!EmitAtomOp(cx, pn2, op, cg))
                     return JS_FALSE;
             }
             break;
           case TOK_DOT:
             if (!EmitPropOp(cx, pn2, op, cg))
                 return JS_FALSE;
+            /*
+             * Allocate an extra stack slot for GC protection in case the
+             * initial value being post-incremented or -decremented is not
+             * a number, but converts to a jsdouble.  See jsinterp.c, the
+             * JSOP_PROPINC and JSOP_PROPDEC cases.
+             */
+            if ((js_CodeSpec[op].format & JOF_POST) &&
+                cg->stackDepth == cg->maxStackDepth) {
+                ++cg->maxStackDepth;
+            }
             break;
           case TOK_LB:
             if (!EmitElemOp(cx, pn2, op, cg))
                 return JS_FALSE;
             break;
 #if JS_HAS_LVALUE_RETURN
           case TOK_LP:
             if (!js_EmitTree(cx, cg, pn2))
--- jsinterp.c	10 Nov 2005 07:09:22 -0000	3.203
+++ jsinterp.c	18 Nov 2005 08:51:23 -0000
@@ -2679,16 +2679,17 @@ js_Interpret(JSContext *cx, jsbytecode *
                 cond = JSVAL_TO_INT(lval) OP JSVAL_TO_INT(rval);              \
             } else {                                                          \
                 d  = ltmp ? JSVAL_TO_INT(lval) : *rt->jsNaN;                  \
                 d2 = rtmp ? JSVAL_TO_INT(rval) : *rt->jsNaN;                  \
                 cond = JSDOUBLE_COMPARE(d, OP, d2, JS_FALSE);                 \
             }                                                                 \
         } else {                                                              \
             VALUE_TO_PRIMITIVE(cx, lval, JSTYPE_NUMBER, &lval);               \
+            sp[-2] = lval;      /* protect from GC */                         \
             VALUE_TO_PRIMITIVE(cx, rval, JSTYPE_NUMBER, &rval);               \
             if (JSVAL_IS_STRING(lval) && JSVAL_IS_STRING(rval)) {             \
                 str  = JSVAL_TO_STRING(lval);                                 \
                 str2 = JSVAL_TO_STRING(rval);                                 \
                 cond = js_CompareStrings(str, str2) OP 0;                     \
             } else {                                                          \
                 VALUE_TO_NUMBER(cx, lval, d);                                 \
                 VALUE_TO_NUMBER(cx, rval, d2);                                \
@@ -2901,26 +2902,27 @@ js_Interpret(JSContext *cx, jsbytecode *
                 ok = ops->concatenate(cx, obj2, rval, &rval);
                 if (!ok)
                     goto out;
                 sp--;
                 STORE_OPND(-1, rval);
                 break;
             }
 #endif
-            VALUE_TO_PRIMITIVE(cx, lval, JSTYPE_VOID, &ltmp);
-            VALUE_TO_PRIMITIVE(cx, rval, JSTYPE_VOID, &rtmp);
-            if ((cond = JSVAL_IS_STRING(ltmp)) || JSVAL_IS_STRING(rtmp)) {
+            VALUE_TO_PRIMITIVE(cx, lval, JSTYPE_VOID, &lval);
+            sp[-2] = lval;      /* protect from GC */
+            VALUE_TO_PRIMITIVE(cx, rval, JSTYPE_VOID, &rval);
+            if ((cond = JSVAL_IS_STRING(lval)) || JSVAL_IS_STRING(rval)) {
                 SAVE_SP(fp);
                 if (cond) {
-                    str = JSVAL_TO_STRING(ltmp);
-                    ok = (str2 = js_ValueToString(cx, rtmp)) != NULL;
+                    str = JSVAL_TO_STRING(lval);
+                    ok = (str2 = js_ValueToString(cx, rval)) != NULL;
                 } else {
-                    str2 = JSVAL_TO_STRING(rtmp);
-                    ok = (str = js_ValueToString(cx, ltmp)) != NULL;
+                    str2 = JSVAL_TO_STRING(rval);
+                    ok = (str = js_ValueToString(cx, lval)) != NULL;
                 }
                 if (!ok)
                     goto out;
                 str = js_ConcatStrings(cx, str, str2);
                 if (!str) {
                     ok = JS_FALSE;
                     goto out;
                 }
@@ -3218,39 +3220,53 @@ js_Interpret(JSContext *cx, jsbytecode *
                     (cs->format & JOF_INC) ? (rval += 2) : (rval -= 2);
                     rtmp = rval;
                 }
             } else {
 
 /*
  * Initially, rval contains the value to increment or decrement, which is not
  * yet converted.  As above, the expression result goes in rtmp, the updated
- * value goes in rval.
+ * value goes in rval.  Our caller must set vp to point at a GC-rooted jsval
+ * in which we home rtmp, to protect it from GC in case the unconverted rval
+ * is not a number.
  */
 #define NONINT_INCREMENT_OP_MIDDLE()                                          \
     JS_BEGIN_MACRO                                                            \
         VALUE_TO_NUMBER(cx, rval, d);                                         \
         if (cs->format & JOF_POST) {                                          \
             rtmp = rval;                                                      \
             if (!JSVAL_IS_NUMBER(rtmp)) {                                     \
                 ok = js_NewNumberValue(cx, d, &rtmp);                         \
                 if (!ok)                                                      \
                     goto out;                                                 \
+                *vp = rtmp;                                                   \
             }                                                                 \
             (cs->format & JOF_INC) ? d++ : d--;                               \
             ok = js_NewNumberValue(cx, d, &rval);                             \
         } else {                                                              \
             (cs->format & JOF_INC) ? ++d : --d;                               \
             ok = js_NewNumberValue(cx, d, &rval);                             \
             rtmp = rval;                                                      \
         }                                                                     \
         if (!ok)                                                              \
             goto out;                                                         \
     JS_END_MACRO
 
+                if ((cs->format & JOF_POST) && i != -2) {
+                    /*
+                     * We must push early to protect the postfix increment
+                     * or decrement result, if converted to a jsdouble from
+                     * a non-number value, from GC nesting in the setter.
+                     */
+                    ++sp;
+                    --i;
+                    SAVE_SP(fp);
+                }
+                vp = sp - 1;
                 NONINT_INCREMENT_OP_MIDDLE();
             }
 
             fp->flags |= JSFRAME_ASSIGNING;
             CACHED_SET(OBJ_SET_PROPERTY(cx, obj, id, &rval));
             fp->flags &= ~JSFRAME_ASSIGNING;
             if (!ok)
                 goto out;
@@ -3332,19 +3348,21 @@ js_Interpret(JSContext *cx, jsbytecode *
           case JSOP_GVARINC:
             FAST_GLOBAL_INCREMENT_OP(JSOP_NAMEINC, rtmp, +=, MAX);
           case JSOP_GVARDEC:
             FAST_GLOBAL_INCREMENT_OP(JSOP_NAMEDEC, rtmp, -=, MIN);
 
 #undef FAST_GLOBAL_INCREMENT_OP
 
           do_nonint_fast_global_incop:
+            vp = sp++;
+            SAVE_SP(fp);
             NONINT_INCREMENT_OP_MIDDLE();
             OBJ_SET_SLOT(cx, obj, slot, rval);
-            PUSH_OPND(rtmp);
+            STORE_OPND(-1, rtmp);
             break;
 
           case JSOP_GETPROP:
             /* Get an immediate atom naming the property. */
             atom = GET_ATOM(cx, script, pc);
             id   = ATOM_TO_JSID(atom);
             PROPERTY_OP(-1, CACHED_GET(OBJ_GET_PROPERTY(cx, obj, id, &rval)));
             STORE_OPND(-1, rval);
