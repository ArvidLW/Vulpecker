diff --git a/modules/plugin/base/src/nsPluginNativeWindowWin.cpp b/modules/plugin/base/src/nsPluginNativeWindowWin.cpp
--- a/modules/plugin/base/src/nsPluginNativeWindowWin.cpp
+++ b/modules/plugin/base/src/nsPluginNativeWindowWin.cpp
@@ -58,16 +58,19 @@
 #include "nsPluginNativeWindow.h"
 #include "nsThreadUtils.h"
 #include "nsAutoPtr.h"
 #include "nsTWeakRef.h"
 
 static NS_DEFINE_CID(kCPluginManagerCID, NS_PLUGINMANAGER_CID); // needed for NS_TRY_SAFE_CALL
 
 #define NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION TEXT("MozillaPluginWindowPropertyAssociation")
+#define NS_PLUGIN_CUSTOM_MSG_ID TEXT("MozFlashUserRelay")
+#define WM_USER_FLASH WM_USER+1
+static UINT sWM_FLASHBOUNCEMSG = 0;
 
 typedef nsTWeakRef<class nsPluginNativeWindowWin> PluginWindowWeakRef;
 
 /**
  *  PLEvent handling code
  */
 class PluginWindowEvent : public nsRunnable {
 public:
@@ -157,22 +160,31 @@ private:
 
 public:
   nsPluginType mPluginType;
 };
 
 static PRBool sInMessageDispatch = PR_FALSE;
 static UINT sLastMsg = 0;
 
-static PRBool ProcessFlashMessageDelayed(nsPluginNativeWindowWin * aWin, 
+static PRBool ProcessFlashMessageDelayed(nsPluginNativeWindowWin * aWin, nsIPluginInstance * aInst,
                                          HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
 {
   NS_ENSURE_TRUE(aWin, NS_ERROR_NULL_POINTER);
+  NS_ENSURE_TRUE(aInst, NS_ERROR_NULL_POINTER);
 
-  if (msg != WM_USER+1)
+  if (msg == sWM_FLASHBOUNCEMSG) {
+    // See PluginWindowEvent::Run() below.
+    NS_ASSERTION((sWM_FLASHBOUNCEMSG != 0), "RegisterWindowMessage failed in flash plugin WM_USER message handling!");
+    NS_TRY_SAFE_CALL_VOID(::CallWindowProc((WNDPROC)aWin->GetWindowProc(), hWnd, WM_USER_FLASH, wParam, lParam),
+                                           nsnull, aInst);
+    return TRUE;
+  }
+
+  if (msg != WM_USER_FLASH)
     return PR_FALSE; // no need to delay
 
   // do stuff
   nsCOMPtr<nsIRunnable> pwe = aWin->GetPluginWindowEvent(hWnd, msg, wParam, lParam);
   if (pwe) {
     NS_DispatchToCurrentThread(pwe);
     return PR_TRUE;  
   }
@@ -329,17 +341,17 @@ static LRESULT CALLBACK PluginWndProc(HW
     }
 #endif
   }
 
   // Macromedia Flash plugin may flood the message queue with some special messages
   // (WM_USER+1) causing 100% CPU consumption and GUI freeze, see mozilla bug 132759;
   // we can prevent this from happening by delaying the processing such messages;
   if (win->mPluginType == nsPluginType_Flash) {
-    if (ProcessFlashMessageDelayed(win, hWnd, msg, wParam, lParam))
+    if (ProcessFlashMessageDelayed(win, inst, hWnd, msg, wParam, lParam))
       return TRUE;
   }
 
   LRESULT res = TRUE;
 
   nsCOMPtr<nsIPluginInstanceInternal> instInternal;
 
   if (enablePopups) {
@@ -396,16 +408,20 @@ nsPluginNativeWindowWin::nsPluginNativeW
   x = 0; 
   y = 0; 
   width = 0; 
   height = 0; 
 
   mPrevWinProc = NULL;
   mPluginWinProc = NULL;
   mPluginType = nsPluginType_Unknown;
+  
+  if (sWM_FLASHBOUNCEMSG == 0)
+    sWM_FLASHBOUNCEMSG = ::RegisterWindowMessage(NS_PLUGIN_CUSTOM_MSG_ID);
+
 }
 
 nsPluginNativeWindowWin::~nsPluginNativeWindowWin()
 {
   // clear weak reference to self to prevent any pending events from
   // dereferencing this.
   mWeakRef.forget();
 }
@@ -427,22 +443,33 @@ NS_IMETHODIMP PluginWindowEvent::Run()
     return NS_OK;
 
   HWND hWnd = GetWnd();
   if (!hWnd)
     return NS_OK;
 
   nsCOMPtr<nsIPluginInstance> inst;
   win->GetPluginInstance(inst);
-  NS_TRY_SAFE_CALL_VOID(::CallWindowProc(win->GetWindowProc(), 
-                        hWnd, 
-                        GetMsg(), 
-                        GetWParam(), 
-                        GetLParam()),
-                        nsnull, inst);
+
+  if (GetMsg() == WM_USER_FLASH) {
+    // XXX Unwind issues related to runnable event callback depth for this
+    // event and destruction of the plugin. (Bug 493601)
+    ::PostMessage(hWnd, sWM_FLASHBOUNCEMSG, GetWParam(), GetLParam());
+  }
+  else {
+    // Currently not used, but added so that processing events here
+    // is more generic.
+    NS_TRY_SAFE_CALL_VOID(::CallWindowProc(win->GetWindowProc(), 
+                          hWnd, 
+                          GetMsg(), 
+                          GetWParam(), 
+                          GetLParam()),
+                          nsnull, inst);
+  }
+
   Clear();
   return NS_OK;
 }
 
 PluginWindowEvent * 
 nsPluginNativeWindowWin::GetPluginWindowEvent(HWND aWnd, UINT aMsg, WPARAM aWParam, LPARAM aLParam)
 {
   if (!mWeakRef) {
