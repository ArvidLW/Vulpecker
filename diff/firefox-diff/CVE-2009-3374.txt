diff --git a/js/src/xpconnect/src/xpcvariant.cpp b/js/src/xpconnect/src/xpcvariant.cpp
--- a/js/src/xpconnect/src/xpcvariant.cpp
+++ b/js/src/xpconnect/src/xpcvariant.cpp
@@ -396,16 +412,25 @@ XPCVariant::VariantDataToJS(XPCCallConte
         {
             // Not a JSObject (or is a JSArray or is a JSObject representing 
             // an nsID),.
             // So, just pass through the underlying data.
             *pJSVal = realVal;
             return JS_TRUE;
         }
 
+        if(xpcvariant->mReturnRawObject)
+        {
+            NS_ASSERTION(type == nsIDataType::VTYPE_INTERFACE ||
+                         type == nsIDataType::VTYPE_INTERFACE_IS,
+                         "Weird variant");
+            *pJSVal = realVal;
+            return JS_TRUE;
+        }
+
         // else, it's an object and we really need to double wrap it if we've 
         // already decided that its 'natural' type is as some sort of interface.
         
         // We just fall through to the code below and let it do what it does.
     }
 
     // The nsIVariant is not a XPCVariant (or we act like it isn't).
     // So we extract the data and do the Right Thing.
@@ -636,50 +661,20 @@ VARIANT_DONE:
     {
         success = XPCConvert::NativeStringWithSize2JS(ccx, pJSVal,
                                                       (const void*)&xpctvar.val,
                                                       xpctvar.type,
                                                       size, pErr);
     }
     else
     {
-        // Last ditch check to prevent us from double-wrapping a regular JS
-        // object. This allows us to unwrap regular JS objects (since we
-        // normally can't double wrap them). See bug 384632.
-        *pJSVal = JSVAL_VOID;
-        if(type == nsIDataType::VTYPE_INTERFACE ||
-           type == nsIDataType::VTYPE_INTERFACE_IS)
-        {
-            nsISupports *src = reinterpret_cast<nsISupports *>(xpctvar.val.p);
-            if(nsXPCWrappedJSClass::IsWrappedJS(src))
-            {
-                // First QI the wrapper to the right interface.
-                nsCOMPtr<nsISupports> wrapper;
-                nsresult rv = src->QueryInterface(iid, getter_AddRefs(wrapper));
-                NS_ENSURE_SUCCESS(rv, JS_FALSE);
-
-                // Now, get the actual JS object out of the wrapper.
-                nsCOMPtr<nsIXPConnectJSObjectHolder> holder =
-                    do_QueryInterface(wrapper);
-                NS_ENSURE_TRUE(holder, JS_FALSE);
-
-                JSObject *obj;
-                holder->GetJSObject(&obj);
-                NS_ASSERTION(obj, "No JS object but the QIs above succeeded?");
-                *pJSVal = OBJECT_TO_JSVAL(obj);
-                success = JS_TRUE;
-            }
-        }
-        if(!JSVAL_IS_OBJECT(*pJSVal))
-        {
-            success = XPCConvert::NativeData2JS(ccx, pJSVal,
-                                                (const void*)&xpctvar.val,
-                                                xpctvar.type,
-                                                &iid, scope, pErr);
-        }
+        success = XPCConvert::NativeData2JS(ccx, pJSVal,
+                                            (const void*)&xpctvar.val,
+                                            xpctvar.type,
+                                            &iid, scope, pErr);
     }
 
     if(xpctvar.IsValAllocated())
         nsMemory::Free((char*)xpctvar.val.p);
     else if(xpctvar.IsValInterface())
         ((nsISupports*)xpctvar.val.p)->Release();
 
     return success;
