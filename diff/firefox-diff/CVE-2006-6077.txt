--- toolkit/components/passwordmgr/base/nsPasswordManager.cpp	29 Aug 2005 22:43:43 -0000	1.65.2.4
+++ toolkit/components/passwordmgr/base/nsPasswordManager.cpp	4 Dec 2006 17:45:10 -0000
@@ -810,16 +810,20 @@ nsPasswordManager::OnStateChange(nsIWebP
     return NS_OK;
 
   SignonHashEntry* hashEnt;
   if (!mSignonTable.Get(realm, &hashEnt))
     return NS_OK;
 
   PRUint32 formCount;
   forms->GetLength(&formCount);
+  
+  // check to see if we should formfill.  failure is non-fatal
+  PRBool prefillForm = PR_TRUE;
+  mPrefBranch->GetBoolPref("prefillForms", &prefillForm);
 
   // We can auto-prefill the username and password if there is only
   // one stored login that matches the username and password field names
   // on the form in question.  Note that we only need to worry about a
   // single login per form.
 
   for (PRUint32 i = 0; i < formCount; ++i) {
     nsCOMPtr<nsIDOMNode> formNode;
@@ -901,17 +905,17 @@ nsPasswordManager::OnStateChange(nsIWebP
           continue;
 
         temp->GetValue(oldPassValue);
         passField = temp;
       } else {
         continue;
       }
 
-      if (!oldUserValue.IsEmpty()) {
+      if (!oldUserValue.IsEmpty() && prefillForm) {
         // The page has prefilled a username.
         // If it matches any of our saved usernames, prefill the password
         // for that username.  If there are multiple saved usernames,
         // we will also attach the autocomplete listener.
 
         nsAutoString userValue;
         if (NS_FAILED(DecryptData(e->userValue, userValue)))
           goto done;
@@ -936,27 +940,29 @@ nsPasswordManager::OnStateChange(nsIWebP
         attachedToInput = PR_TRUE;
       } else {
         firstMatch = e;
       }
     }
 
     if (firstMatch && !attachedToInput) {
       nsAutoString buffer;
+      AttachToInput(userField);
+      
+      if (prefillForm) {
+        if (NS_FAILED(DecryptData(firstMatch->userValue, buffer)))
+          goto done;
 
-      if (NS_FAILED(DecryptData(firstMatch->userValue, buffer)))
-        goto done;
-
-      userField->SetValue(buffer);
+        userField->SetValue(buffer);
 
-      if (NS_FAILED(DecryptData(firstMatch->passValue, buffer)))
-        goto done;
+        if (NS_FAILED(DecryptData(firstMatch->passValue, buffer)))
+          goto done;
 
-      passField->SetValue(buffer);
-      AttachToInput(userField);
+        passField->SetValue(buffer);
+      }
     }
   }
 
  done:
   nsCOMPtr<nsIDOMEventTarget> targ = do_QueryInterface(domDoc);
   targ->AddEventListener(NS_LITERAL_STRING("unload"),
                          NS_STATIC_CAST(nsIDOMLoadListener*, this), PR_FALSE);
 
