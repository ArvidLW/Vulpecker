--- modules/libpr0n/decoders/gif/GIF2.cpp	20 Aug 2003 18:06:33 -0000	1.41.4.2
+++ modules/libpr0n/decoders/gif/GIF2.cpp	30 Jun 2005 06:24:54 -0000
@@ -487,18 +487,17 @@ PRBool GIFInit(gif_struct* gs, void* aCl
 #define MAX_READ_AHEAD  (0xFFFFFFL)
 
 //******************************************************************************
 PRBool gif_write_ready(const gif_struct* gs)
 {
   if (!gs)
     return PR_FALSE;
 
-  PRInt32 max = PR_MAX(MAX_READ_AHEAD, gs->requested_buffer_fullness);
-  return (gs->gathered < max);
+  return (gs->gathered < MAX_READ_AHEAD);
 }
 
 /******************************************************************************/
 /*
  * process data arriving from the stream for the gif decoder
  */
 
 PRStatus gif_write(gif_struct *gs, const PRUint8 *buf, PRUint32 len)
@@ -793,30 +792,27 @@ PRStatus gif_write(gif_struct *gs, const
         /* Zero loop count is infinite animation loop request */
         if (gs->loop_count == 0)
           gs->loop_count = -1;
 
         GETN(1, gif_netscape_extension_block);
       }
       /* Wait for specified # of bytes to enter buffer */
       else if (netscape_extension == 2) {
-        gs->requested_buffer_fullness = GETINT32(q + 1);
-        GETN(gs->requested_buffer_fullness, gif_wait_for_buffer_full);
+        // Don't do this, this extension doesn't exist (isn't used at all) 
+        // and doesn't do anything, as our streaming/buffering takes care of it all...
+        // See: http://semmix.pl/color/exgraf/eeg24.htm
+        GETN(1, gif_netscape_extension_block);
       } else
         gs->state = gif_error; // 0,3-7 are yet to be defined netscape
                                // extension codes
 
       break;
     }
 
-    case gif_wait_for_buffer_full:
-      gs->gathered = gs->requested_buffer_fullness;
-      GETN(1, gif_netscape_extension_block);
-      break;
-
     case gif_image_header:
     {
       PRUintn height, width;
 
       /* Get image offsets, with respect to the screen origin */
       gs->x_offset = GETINT16(q);
       gs->y_offset = GETINT16(q + 2);
 
@@ -908,17 +904,16 @@ PRStatus gif_write(gif_struct *gs, const
            requires saving the underlying image in order to
            avoid jaggies at the transparency edges.  We are
            unprepared to deal with that, so don't display such
            images progressively */
         gs->progressive_display = PR_FALSE;
       }
 
       /* Clear state from last image */
-      gs->requested_buffer_fullness = 0;
       gs->irow = 0;
       gs->rows_remaining = gs->height;
       gs->rowend = gs->rowbuf + gs->width;
       gs->rowp = gs->rowbuf;
 
       /* bits per pixel is 1<<((q[8]&0x07) + 1); */
 
       if (q[8] & 0x80) /* has a local colormap? */

--- modules/libpr0n/decoders/gif/GIF2.h	1 May 2003 18:18:38 -0000	1.16
+++ modules/libpr0n/decoders/gif/GIF2.h	30 Jun 2005 06:24:54 -0000
@@ -63,17 +63,16 @@ typedef enum {
     gif_oom,
     gif_error,
     gif_comment_extension,
     gif_application_extension,
     gif_netscape_extension_block,
     gif_consume_netscape_extension,
     gif_consume_comment,
     gif_delay,
-    gif_wait_for_buffer_full,
     gif_stop_animating   //added for animation stop 
 } gstate;
 
 /* "Disposal" method indicates how the image should be handled in the
    framebuffer before the subsequent image is displayed. */
 typedef enum 
 {
     DISPOSE_NOT_SPECIFIED      = 0,
@@ -88,17 +87,16 @@ typedef struct gif_struct {
     /* Parsing state machine */
     gstate state;               /* Curent decoder master state */
     PRUint8 *hold;                /* Accumulation buffer */
     int32 hold_size;            /* Capacity, in bytes, of accumulation buffer */
     PRUint8 *gather_head;         /* Next byte to read in accumulation buffer */
     int32 gather_request_size;  /* Number of bytes to accumulate */
     int32 gathered;             /* bytes accumulated so far*/
     gstate post_gather_state;   /* State after requested bytes accumulated */
-    int32 requested_buffer_fullness; /* For netscape application extension */
 
     /* LZW decoder state machine */
     PRUint8 *stack;               /* Base of decoder stack */
     PRUint8 *stackp;              /* Current stack pointer */
     PRUint16 *prefix;
     PRUint8 *suffix;
     int datasize;
     int codesize;
